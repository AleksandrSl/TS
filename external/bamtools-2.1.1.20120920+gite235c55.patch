Index: bamtools/src/api/internal/bam/BamWriter_p.h
===================================================================
--- bamtools/src/api/internal/bam/BamWriter_p.h	(revision 34298)
+++ bamtools/src/api/internal/bam/BamWriter_p.h	(revision 43014)
@@ -48,6 +48,7 @@
                   const BamTools::RefVector& referenceSequences);
         bool SaveAlignment(const BamAlignment& al);
         void SetWriteCompressed(bool ok);
+        void SetParallel(int32_t);
 
     // 'internal' methods
     public:
@@ -62,9 +63,11 @@
 
     // data members
     private:
-        BgzfStream m_stream;
+        BgzfStream *m_stream;
         bool m_isBigEndian;
         std::string m_errorString;
+        int32_t m_numThreads;
+        int32_t m_writeCompressed;
 };
 
 } // namespace Internal
Index: bamtools/src/api/internal/bam/BamReader_p.cpp
===================================================================
--- bamtools/src/api/internal/bam/BamReader_p.cpp	(revision 34298)
+++ bamtools/src/api/internal/bam/BamReader_p.cpp	(revision 43014)
@@ -16,6 +16,9 @@
 #include "api/internal/index/BamStandardIndex_p.h"
 #include "api/internal/index/BamToolsIndex_p.h"
 #include "api/internal/io/BamDeviceFactory_p.h"
+#include "api/internal/io/BgzfStream_p.h"
+#include "api/internal/io/SerialBgzfStream_p.h"
+#include "api/internal/io/ParallelBgzfStream_p.h"
 #include "api/internal/utils/BamException_p.h"
 using namespace BamTools;
 using namespace BamTools::Internal;
@@ -31,6 +34,8 @@
 BamReaderPrivate::BamReaderPrivate(BamReader* parent)
     : m_alignmentsBeginOffset(0)
     , m_parent(parent)
+    , m_stream(NULL)
+    , m_numThreads(0)
 {
     m_isBigEndian = BamTools::SystemIsBigEndian();
 }
@@ -56,13 +61,15 @@
     // if stream is open, attempt close
     if ( IsOpen() ) {
         try {
-            m_stream.Close();
+            m_stream->Close();
         } catch ( BamException& e ) {
             const string streamError = e.what();
             const string message = string("encountered error closing BAM file: \n\t") + streamError;
             SetErrorString("BamReader::Close", message);
             return false;
         }
+        delete m_stream;
+        m_stream = NULL;
     }
 
     // return success
@@ -139,7 +146,7 @@
 bool BamReaderPrivate::GetNextAlignmentCore(BamAlignment& alignment) {
 
     // skip if stream not opened
-    if ( !m_stream.IsOpen() )
+    if ( NULL == m_stream || !m_stream->IsOpen() )
         return false;
 
     try {
@@ -219,12 +226,12 @@
 }
 
 bool BamReaderPrivate::IsOpen(void) const {
-    return m_stream.IsOpen();
+    return ( NULL != m_stream && m_stream->IsOpen() );
 }
 
 // load BAM header data
 void BamReaderPrivate::LoadHeaderData(void) {
-    m_header.Load(&m_stream);
+    m_header.Load(m_stream);
 }
 
 // populates BamAlignment with alignment data under file pointer, returns success/fail
@@ -233,7 +240,7 @@
     // read in the 'block length' value, make sure it's not zero
     char buffer[sizeof(uint32_t)];
     fill_n(buffer, sizeof(uint32_t), 0);
-    m_stream.Read(buffer, sizeof(uint32_t));
+    m_stream->Read(buffer, sizeof(uint32_t));
     alignment.SupportData.BlockLength = BamTools::UnpackUnsignedInt(buffer);
     if ( m_isBigEndian ) BamTools::SwapEndian_32(alignment.SupportData.BlockLength);
     if ( alignment.SupportData.BlockLength == 0 )
@@ -241,7 +248,7 @@
 
     // read in core alignment data, make sure the right size of data was read
     char x[Constants::BAM_CORE_SIZE];
-    if ( m_stream.Read(x, Constants::BAM_CORE_SIZE) != Constants::BAM_CORE_SIZE )
+    if ( m_stream->Read(x, Constants::BAM_CORE_SIZE) != Constants::BAM_CORE_SIZE )
         return false;
 
     // swap core endian-ness if necessary
@@ -276,7 +283,7 @@
     const unsigned int dataLength = alignment.SupportData.BlockLength - Constants::BAM_CORE_SIZE;
     RaiiBuffer allCharData(dataLength);
 
-    if ( m_stream.Read(allCharData.Buffer, dataLength) == dataLength ) {
+    if ( m_stream->Read(allCharData.Buffer, dataLength) == dataLength ) {
 
         // store 'allCharData' in supportData structure
         alignment.SupportData.AllCharData.assign((const char*)allCharData.Buffer, dataLength);
@@ -315,7 +322,7 @@
 
     // get number of reference sequences
     char buffer[sizeof(uint32_t)];
-    m_stream.Read(buffer, sizeof(uint32_t));
+    m_stream->Read(buffer, sizeof(uint32_t));
     uint32_t numberRefSeqs = BamTools::UnpackUnsignedInt(buffer);
     if ( m_isBigEndian ) BamTools::SwapEndian_32(numberRefSeqs);
     m_references.reserve((int)numberRefSeqs);
@@ -324,14 +331,14 @@
     for ( unsigned int i = 0; i != numberRefSeqs; ++i ) {
 
         // get length of reference name
-        m_stream.Read(buffer, sizeof(uint32_t));
+        m_stream->Read(buffer, sizeof(uint32_t));
         uint32_t refNameLength = BamTools::UnpackUnsignedInt(buffer);
         if ( m_isBigEndian ) BamTools::SwapEndian_32(refNameLength);
         RaiiBuffer refName(refNameLength);
 
         // get reference name and reference sequence length
-        m_stream.Read(refName.Buffer, refNameLength);
-        m_stream.Read(buffer, sizeof(int32_t));
+        m_stream->Read(refName.Buffer, refNameLength);
+        m_stream->Read(buffer, sizeof(int32_t));
         int32_t refLength = BamTools::UnpackSignedInt(buffer);
         if ( m_isBigEndian ) BamTools::SwapEndian_32(refLength);
 
@@ -366,8 +373,13 @@
         // make sure we're starting with fresh state
         Close();
 
+        if ( 1 <= m_numThreads )
+            m_stream = new ParallelBgzfStream(m_numThreads);
+        else
+            m_stream = new SerialBgzfStream();
+
         // open BgzfStream
-        m_stream.Open(filename, IBamIODevice::ReadOnly);
+        m_stream->Open(filename, IBamIODevice::ReadOnly);
 
         // load BAM metadata
         LoadHeaderData();
@@ -375,7 +387,7 @@
 
         // store filename & offset of first alignment
         m_filename = filename;
-        m_alignmentsBeginOffset = m_stream.Tell();
+        m_alignmentsBeginOffset = m_stream->Tell();
 
         // return success
         return true;
@@ -427,7 +439,7 @@
     }
 
     try {
-        m_stream.Seek(position);
+        m_stream->Seek(position);
         return true;
     }
     catch ( BamException& e ) {
@@ -462,5 +474,9 @@
 }
 
 int64_t BamReaderPrivate::Tell(void) const {
-    return m_stream.Tell();
+    return m_stream->Tell();
 }
+
+void BamReaderPrivate::SetParallel(int numThreads) {
+    m_numThreads = numThreads;
+}
Index: bamtools/src/api/internal/bam/BamReader_p.h
===================================================================
--- bamtools/src/api/internal/bam/BamReader_p.h	(revision 34298)
+++ bamtools/src/api/internal/bam/BamReader_p.h	(revision 43014)
@@ -72,6 +72,8 @@
         std::string GetErrorString(void) const;
         void SetErrorString(const std::string& where, const std::string& what);
 
+        void SetParallel(int32_t);
+
     // internal methods, but available as a BamReaderPrivate 'interface'
     //
     // these methods should only be used by BamTools::Internal classes
@@ -106,10 +108,12 @@
         // BamReaderPrivate components
         BamHeader m_header;
         BamRandomAccessController m_randomAccessController;
-        BgzfStream m_stream;
+        BgzfStream *m_stream;
 
         // error handling
         std::string m_errorString;
+
+        int32_t m_numThreads;
 };
 
 } // namespace Internal
Index: bamtools/src/api/internal/bam/BamWriter_p.cpp
===================================================================
--- bamtools/src/api/internal/bam/BamWriter_p.cpp	(revision 34298)
+++ bamtools/src/api/internal/bam/BamWriter_p.cpp	(revision 43014)
@@ -11,6 +11,9 @@
 #include "api/BamConstants.h"
 #include "api/IBamIODevice.h"
 #include "api/internal/bam/BamWriter_p.h"
+#include "api/internal/io/BgzfStream_p.h"
+#include "api/internal/io/SerialBgzfStream_p.h"
+#include "api/internal/io/ParallelBgzfStream_p.h"
 #include "api/internal/utils/BamException_p.h"
 using namespace BamTools;
 using namespace BamTools::Internal;
@@ -22,6 +25,8 @@
 // ctor
 BamWriterPrivate::BamWriterPrivate(void)
     : m_isBigEndian( BamTools::SystemIsBigEndian() )
+    , m_stream(NULL)
+    , m_numThreads(0)
 { }
 
 // dtor
@@ -48,10 +53,13 @@
 
     // close output stream
     try {
-        m_stream.Close();
+        m_stream->Close();
     } catch ( BamException& e ) {
         m_errorString = e.what();
     }
+
+    delete m_stream;
+    m_stream = NULL;
 }
 
 // creates a cigar string from the supplied alignment
@@ -149,7 +157,9 @@
 
 // returns whether BAM file is open for writing or not
 bool BamWriterPrivate::IsOpen(void) const {
-    return m_stream.IsOpen();
+    if ( NULL == m_stream )
+      return false;
+    return m_stream->IsOpen();
 }
 
 // opens the alignment archive
@@ -159,9 +169,16 @@
 {
     try {
 
+        if ( 1 <= m_numThreads )
+            m_stream = new ParallelBgzfStream(m_numThreads);
+        else
+            m_stream = new SerialBgzfStream();
+
         // open the BGZF file for writing
-        m_stream.Open(filename, IBamIODevice::WriteOnly);
+        m_stream->Open(filename, IBamIODevice::WriteOnly);
 
+        m_stream->SetWriteCompressed(m_writeCompressed);
+
         // write BAM file 'metadata' components
         WriteMagicNumber();
         WriteSamHeaderText(samHeaderText);
@@ -202,7 +219,7 @@
 void BamWriterPrivate::SetWriteCompressed(bool ok) {
     // modifying compression is not allowed if BAM file is open
     if ( !IsOpen() )
-        m_stream.SetWriteCompressed(ok);
+        m_writeCompressed = ok;
 }
 
 void BamWriterPrivate::WriteAlignment(const BamAlignment& al) {
@@ -238,7 +255,7 @@
                                        tagDataLength;
     unsigned int blockSize = Constants::BAM_CORE_SIZE + dataBlockSize;
     if ( m_isBigEndian ) BamTools::SwapEndian_32(blockSize);
-    m_stream.Write((char*)&blockSize, Constants::BAM_SIZEOF_INT);
+    m_stream->Write((char*)&blockSize, Constants::BAM_SIZEOF_INT);
 
     // assign the BAM core data
     uint32_t buffer[Constants::BAM_CORE_BUFFER_SIZE];
@@ -258,10 +275,10 @@
     }
 
     // write the BAM core
-    m_stream.Write((char*)&buffer, Constants::BAM_CORE_SIZE);
+    m_stream->Write((char*)&buffer, Constants::BAM_CORE_SIZE);
 
     // write the query name
-    m_stream.Write(al.Name.c_str(), nameLength);
+    m_stream->Write(al.Name.c_str(), nameLength);
 
     // write the packed cigar
     if ( m_isBigEndian ) {
@@ -271,16 +288,16 @@
             for ( size_t i = 0; i < packedCigarLength; ++i )
                 BamTools::SwapEndian_32p(&cigarData[i]);
         }
-        m_stream.Write(cigarData, packedCigarLength);
+        m_stream->Write(cigarData, packedCigarLength);
         delete[] cigarData; // TODO: cleanup on Write exception thrown?
     }
     else
-        m_stream.Write(packedCigar.data(), packedCigarLength);
+        m_stream->Write(packedCigar.data(), packedCigarLength);
 
     if ( queryLength > 0 ) {
 
         // write the encoded query sequence
-        m_stream.Write(encodedQuery.data(), encodedQueryLength);
+        m_stream->Write(encodedQuery.data(), encodedQueryLength);
 
         // write the base qualities
         char* pBaseQualities = new char[queryLength]();
@@ -290,7 +307,7 @@
             for ( size_t i = 0; i < queryLength; ++i )
                 pBaseQualities[i] = al.Qualities.at(i) - 33; // FASTQ ASCII -> phred score conversion
         }
-        m_stream.Write(pBaseQualities, queryLength);
+        m_stream->Write(pBaseQualities, queryLength);
         delete[] pBaseQualities;
     }
 
@@ -386,11 +403,11 @@
             }
         }
 
-        m_stream.Write(tagData, tagDataLength);
+        m_stream->Write(tagData, tagDataLength);
         delete[] tagData; // TODO: cleanup on Write exception thrown?
     }
     else
-        m_stream.Write(al.TagData.data(), tagDataLength);
+        m_stream->Write(al.TagData.data(), tagDataLength);
 }
 
 void BamWriterPrivate::WriteCoreAlignment(const BamAlignment& al) {
@@ -398,7 +415,7 @@
     // write the block size
     unsigned int blockSize = al.SupportData.BlockLength;
     if ( m_isBigEndian ) BamTools::SwapEndian_32(blockSize);
-    m_stream.Write((char*)&blockSize, Constants::BAM_SIZEOF_INT);
+    m_stream->Write((char*)&blockSize, Constants::BAM_SIZEOF_INT);
 
     // re-calculate bin (in case BamAlignment's position has been previously modified)
     const uint32_t alignmentBin = CalculateMinimumBin(al.Position, al.GetEndPosition());
@@ -421,16 +438,16 @@
     }
 
     // write the BAM core
-    m_stream.Write((char*)&buffer, Constants::BAM_CORE_SIZE);
+    m_stream->Write((char*)&buffer, Constants::BAM_CORE_SIZE);
 
     // write the raw char data
-    m_stream.Write((char*)al.SupportData.AllCharData.data(),
+    m_stream->Write((char*)al.SupportData.AllCharData.data(),
                    al.SupportData.BlockLength-Constants::BAM_CORE_SIZE);
 }
 
 void BamWriterPrivate::WriteMagicNumber(void) {
     // write BAM file 'magic number'
-    m_stream.Write(Constants::BAM_HEADER_MAGIC, Constants::BAM_HEADER_MAGIC_LENGTH);
+    m_stream->Write(Constants::BAM_HEADER_MAGIC, Constants::BAM_HEADER_MAGIC_LENGTH);
 }
 
 void BamWriterPrivate::WriteReferences(const BamTools::RefVector& referenceSequences) {
@@ -438,7 +455,7 @@
     // write the number of reference sequences
     uint32_t numReferenceSequences = referenceSequences.size();
     if ( m_isBigEndian ) BamTools::SwapEndian_32(numReferenceSequences);
-    m_stream.Write((char*)&numReferenceSequences, Constants::BAM_SIZEOF_INT);
+    m_stream->Write((char*)&numReferenceSequences, Constants::BAM_SIZEOF_INT);
 
     // foreach reference sequence
     RefVector::const_iterator rsIter = referenceSequences.begin();
@@ -449,15 +466,15 @@
         const uint32_t actualNameLen = rsIter->RefName.size() + 1;
         uint32_t maybeSwappedNameLen = actualNameLen;
         if ( m_isBigEndian ) BamTools::SwapEndian_32(maybeSwappedNameLen);
-        m_stream.Write((char*)&maybeSwappedNameLen, Constants::BAM_SIZEOF_INT);
+        m_stream->Write((char*)&maybeSwappedNameLen, Constants::BAM_SIZEOF_INT);
 
         // write the reference sequence name
-        m_stream.Write(rsIter->RefName.c_str(), actualNameLen);
+        m_stream->Write(rsIter->RefName.c_str(), actualNameLen);
 
         // write the reference sequence length
         int32_t referenceLength = rsIter->RefLength;
         if ( m_isBigEndian ) BamTools::SwapEndian_32(referenceLength);
-        m_stream.Write((char*)&referenceLength, Constants::BAM_SIZEOF_INT);
+        m_stream->Write((char*)&referenceLength, Constants::BAM_SIZEOF_INT);
     }
 }
 
@@ -467,9 +484,13 @@
     const uint32_t actualHeaderLen = samHeaderText.size();
     uint32_t maybeSwappedHeaderLen = samHeaderText.size();
     if ( m_isBigEndian ) BamTools::SwapEndian_32(maybeSwappedHeaderLen);
-    m_stream.Write((char*)&maybeSwappedHeaderLen, Constants::BAM_SIZEOF_INT);
+    m_stream->Write((char*)&maybeSwappedHeaderLen, Constants::BAM_SIZEOF_INT);
 
     // write the SAM header text
     if ( actualHeaderLen > 0 )
-        m_stream.Write(samHeaderText.data(), actualHeaderLen);
+        m_stream->Write(samHeaderText.data(), actualHeaderLen);
 }
+
+void BamWriterPrivate::SetParallel(int numThreads) {
+    m_numThreads = numThreads;
+}
Index: bamtools/src/api/internal/io/ParallelBgzfStream_p.h
===================================================================
--- bamtools/src/api/internal/io/ParallelBgzfStream_p.h	(revision 0)
+++ bamtools/src/api/internal/io/ParallelBgzfStream_p.h	(revision 43014)
@@ -0,0 +1,72 @@
+// ***************************************************************************
+// ParallelBgzfStream_p.h (c) 2011 Derek Barnett
+// Marth Lab, Department of Biology, Boston College
+// ---------------------------------------------------------------------------
+// Last modified: 17 January 2012(DB)
+// ---------------------------------------------------------------------------
+// Based on BGZF routines developed at the Broad Institute.
+// Provides the basic functionality for reading & writing BGZF files
+// Replaces the old BGZF.* files to avoid clashing with other toolkits
+// ***************************************************************************
+
+#ifndef PARALLELBGZFSTREAM_P_H
+#define PARALLELBGZFSTREAM_P_H
+
+//  -------------
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the BamTools API.  It exists purely as an
+// implementation detail. This header file may change from version to version
+// without notice, or even be removed.
+//
+// We mean it.
+
+#include "api/api_global.h"
+#include "api/BamAux.h"
+#include "api/IBamIODevice.h"
+#include "api/internal/io/pbgzf/pbgzf.h"
+#include "api/internal/io/BgzfStream_p.h"
+#include <string>
+
+namespace BamTools {
+namespace Internal {
+
+class ParallelBgzfStream : public BgzfStream {
+
+    // constructor & destructor
+    public:
+        ParallelBgzfStream(void);
+        ParallelBgzfStream(int numThreads);
+        ~ParallelBgzfStream(void);
+
+    // main interface methods
+    public:
+        // closes BGZF file
+        void Close(void);
+        // returns true if ParallelBgzfStream open for IO
+        bool IsOpen(void) const;
+        // opens the BGZF file
+        void Open(const std::string& filename, const IBamIODevice::OpenMode mode);
+        // reads BGZF data into a byte buffer
+        size_t Read(char* data, const size_t dataLength);
+        // seek to position in BGZF file
+        void Seek(const int64_t& position);
+        // enable/disable compressed output
+        void SetWriteCompressed(bool ok);
+        // get file position in BGZF file
+        int64_t Tell(void) const;
+        // writes the supplied data into the BGZF buffer
+        size_t Write(const char* data, const size_t dataLength);
+
+    // data members
+    public:
+
+        PBGZF *m_pbgzf;
+        int32_t m_numThreads;
+};
+
+} // namespace Internal
+} // namespace BamTools
+
+#endif // PARALLELBGZFSTREAM_P_H
Index: bamtools/src/api/internal/io/BgzfStream_p.cpp
===================================================================
--- bamtools/src/api/internal/io/BgzfStream_p.cpp	(revision 34298)
+++ bamtools/src/api/internal/io/BgzfStream_p.cpp	(revision 43014)
@@ -29,22 +29,6 @@
 // BgzfStream implementation
 // ---------------------------
 
-// constructor
-BgzfStream::BgzfStream(void)
-  : m_blockLength(0)
-  , m_blockOffset(0)
-  , m_blockAddress(0)
-  , m_isWriteCompressed(true)
-  , m_device(0)
-  , m_uncompressedBlock(Constants::BGZF_DEFAULT_BLOCK_SIZE)
-  , m_compressedBlock(Constants::BGZF_MAX_BLOCK_SIZE)
-{ }
-
-// destructor
-BgzfStream::~BgzfStream(void) {
-    Close();
-}
-
 // checks BGZF block header
 bool BgzfStream::CheckBlockHeader(char* header) {
     return (header[0] == Constants::GZIP_ID1 &&
@@ -56,414 +40,3 @@
             header[13] == Constants::BGZF_ID2 &&
             BamTools::UnpackUnsignedShort(&header[14]) == Constants::BGZF_LEN );
 }
-
-// closes BGZF file
-void BgzfStream::Close(void) {
-
-    // skip if no device open
-    if ( m_device == 0 ) return;
-
-    // if writing to file, flush the current BGZF block,
-    // then write an empty block (as EOF marker)
-    if ( m_device->IsOpen() && (m_device->Mode() == IBamIODevice::WriteOnly) ) {
-        FlushBlock();
-        const size_t blockLength = DeflateBlock(0);
-        m_device->Write(m_compressedBlock.Buffer, blockLength);
-    }
-
-    // close device
-    m_device->Close();
-    delete m_device;
-    m_device = 0;
-
-    // ensure our buffers are cleared out
-    m_uncompressedBlock.Clear();
-    m_compressedBlock.Clear();
-
-    // reset state
-    m_blockLength = 0;
-    m_blockOffset = 0;
-    m_blockAddress = 0;
-    m_isWriteCompressed = true;
-}
-
-// compresses the current block
-size_t BgzfStream::DeflateBlock(int32_t blockLength) {
-
-    // initialize the gzip header
-    char* buffer = m_compressedBlock.Buffer;
-    memset(buffer, 0, 18);
-    buffer[0]  = Constants::GZIP_ID1;
-    buffer[1]  = Constants::GZIP_ID2;
-    buffer[2]  = Constants::CM_DEFLATE;
-    buffer[3]  = Constants::FLG_FEXTRA;
-    buffer[9]  = Constants::OS_UNKNOWN;
-    buffer[10] = Constants::BGZF_XLEN;
-    buffer[12] = Constants::BGZF_ID1;
-    buffer[13] = Constants::BGZF_ID2;
-    buffer[14] = Constants::BGZF_LEN;
-
-    // set compression level
-    const int compressionLevel = ( m_isWriteCompressed ? Z_DEFAULT_COMPRESSION : 0 );
-
-    // loop to retry for blocks that do not compress enough
-    int inputLength = blockLength;
-    size_t compressedLength = 0;
-    const unsigned int bufferSize = Constants::BGZF_MAX_BLOCK_SIZE;
-
-    while ( true ) {
-
-        // initialize zstream values
-        z_stream zs;
-        zs.zalloc    = NULL;
-        zs.zfree     = NULL;
-        zs.next_in   = (Bytef*)m_uncompressedBlock.Buffer;
-        zs.avail_in  = inputLength;
-        zs.next_out  = (Bytef*)&buffer[Constants::BGZF_BLOCK_HEADER_LENGTH];
-        zs.avail_out = bufferSize -
-                       Constants::BGZF_BLOCK_HEADER_LENGTH -
-                       Constants::BGZF_BLOCK_FOOTER_LENGTH;
-
-        // initialize the zlib compression algorithm
-        int status = deflateInit2(&zs,
-                                  compressionLevel,
-                                  Z_DEFLATED,
-                                  Constants::GZIP_WINDOW_BITS,
-                                  Constants::Z_DEFAULT_MEM_LEVEL,
-                                  Z_DEFAULT_STRATEGY);
-        if ( status != Z_OK )
-            throw BamException("BgzfStream::DeflateBlock", "zlib deflateInit2 failed");
-
-        // compress the data
-        status = deflate(&zs, Z_FINISH);
-
-        // if not at stream end
-        if ( status != Z_STREAM_END ) {
-
-            deflateEnd(&zs);
-
-            // there was not enough space available in buffer
-            // try to reduce the input length & re-start loop
-            if ( status == Z_OK ) {
-                inputLength -= 1024;
-                if ( inputLength < 0 )
-                    throw BamException("BgzfStream::DeflateBlock", "input reduction failed");
-                continue;
-            }
-
-            throw BamException("BgzfStream::DeflateBlock", "zlib deflate failed");
-        }
-
-        // finalize the compression routine
-        status = deflateEnd(&zs);
-        if ( status != Z_OK )
-            throw BamException("BgzfStream::DeflateBlock", "zlib deflateEnd failed");
-
-        // update compressedLength
-        compressedLength = zs.total_out +
-                           Constants::BGZF_BLOCK_HEADER_LENGTH +
-                           Constants::BGZF_BLOCK_FOOTER_LENGTH;
-        if ( compressedLength > Constants::BGZF_MAX_BLOCK_SIZE )
-            throw BamException("BgzfStream::DeflateBlock", "deflate overflow");
-
-        // quit while loop
-        break;
-    }
-
-    // store the compressed length
-    BamTools::PackUnsignedShort(&buffer[16], static_cast<uint16_t>(compressedLength - 1));
-
-    // store the CRC32 checksum
-    uint32_t crc = crc32(0, NULL, 0);
-    crc = crc32(crc, (Bytef*)m_uncompressedBlock.Buffer, inputLength);
-    BamTools::PackUnsignedInt(&buffer[compressedLength - 8], crc);
-    BamTools::PackUnsignedInt(&buffer[compressedLength - 4], inputLength);
-
-    // ensure that we have less than a block of data left
-    int remaining = blockLength - inputLength;
-    if ( remaining > 0 ) {
-        if ( remaining > inputLength )
-            throw BamException("BgzfStream::DeflateBlock", "after deflate, remainder too large");
-        memcpy(m_uncompressedBlock.Buffer, m_uncompressedBlock.Buffer + inputLength, remaining);
-    }
-
-    // update block data
-    m_blockOffset = remaining;
-
-    // return result
-    return compressedLength;
-}
-
-// flushes the data in the BGZF block
-void BgzfStream::FlushBlock(void) {
-
-    BT_ASSERT_X( m_device, "BgzfStream::FlushBlock() - attempting to flush to null device" );
-
-    // flush all of the remaining blocks
-    while ( m_blockOffset > 0 ) {
-
-        // compress the data block
-        const size_t blockLength = DeflateBlock(m_blockOffset);
-
-        // flush the data to our output device
-        const int64_t numBytesWritten = m_device->Write(m_compressedBlock.Buffer, blockLength);
-
-        // check for device error
-        if ( numBytesWritten < 0 ) {
-            const string message = string("device error: ") + m_device->GetErrorString();
-            throw BamException("BgzfStream::FlushBlock", message);
-        }
-
-        // check that we wrote expected numBytes
-        if ( numBytesWritten != static_cast<int64_t>(blockLength) ) {
-            stringstream s("");
-            s << "expected to write " << blockLength
-              << " bytes during flushing, but wrote " << numBytesWritten;
-            throw BamException("BgzfStream::FlushBlock", s.str());
-        }
-
-        // update block data
-        m_blockAddress += blockLength;
-    }
-}
-
-// decompresses the current block
-size_t BgzfStream::InflateBlock(const size_t& blockLength) {
-
-    // setup zlib stream object
-    z_stream zs;
-    zs.zalloc    = NULL;
-    zs.zfree     = NULL;
-    zs.next_in   = (Bytef*)m_compressedBlock.Buffer + 18;
-    zs.avail_in  = blockLength - 16;
-    zs.next_out  = (Bytef*)m_uncompressedBlock.Buffer;
-    zs.avail_out = Constants::BGZF_DEFAULT_BLOCK_SIZE;
-
-    // initialize
-    int status = inflateInit2(&zs, Constants::GZIP_WINDOW_BITS);
-    if ( status != Z_OK )
-        throw BamException("BgzfStream::InflateBlock", "zlib inflateInit failed");
-
-    // decompress
-    status = inflate(&zs, Z_FINISH);
-    if ( status != Z_STREAM_END ) {
-        inflateEnd(&zs);
-        throw BamException("BgzfStream::InflateBlock", "zlib inflate failed");
-    }
-
-    // finalize
-    status = inflateEnd(&zs);
-    if ( status != Z_OK ) {
-        inflateEnd(&zs);
-        throw BamException("BgzfStream::InflateBlock", "zlib inflateEnd failed");
-    }
-
-    // return result
-    return zs.total_out;
-}
-
-bool BgzfStream::IsOpen(void) const {
-    if ( m_device == 0 )
-        return false;
-    return m_device->IsOpen();
-}
-
-void BgzfStream::Open(const string& filename, const IBamIODevice::OpenMode mode) {
-
-    // close current device if necessary
-    Close();
-    BT_ASSERT_X( (m_device == 0), "BgzfStream::Open() - unable to properly close previous IO device" );
-
-    // retrieve new IO device depending on filename
-    m_device = BamDeviceFactory::CreateDevice(filename);
-    BT_ASSERT_X( m_device, "BgzfStream::Open() - unable to create IO device from filename" );
-
-    // if device fails to open
-    if ( !m_device->Open(mode) ) {
-        const string deviceError = m_device->GetErrorString();
-        const string message = string("could not open BGZF stream: \n\t") + deviceError;
-        throw BamException("BgzfStream::Open", message);
-    }
-}
-
-// reads BGZF data into a byte buffer
-size_t BgzfStream::Read(char* data, const size_t dataLength) {
-
-    if ( dataLength == 0 )
-        return 0;
-
-    // if stream not open for reading
-    BT_ASSERT_X( m_device, "BgzfStream::Read() - trying to read from null device");
-    if ( !m_device->IsOpen() || (m_device->Mode() != IBamIODevice::ReadOnly) )
-        return 0;
-
-    // read blocks as needed until desired data length is retrieved
-    char* output = data;
-    size_t numBytesRead = 0;
-    while ( numBytesRead < dataLength ) {
-
-        // determine bytes available in current block
-        int bytesAvailable = m_blockLength - m_blockOffset;
-
-        // read (and decompress) next block if needed
-        if ( bytesAvailable <= 0 ) {
-            ReadBlock();
-            bytesAvailable = m_blockLength - m_blockOffset;
-            if ( bytesAvailable <= 0 )
-                break;
-        }
-
-        // copy data from uncompressed source buffer into data destination buffer
-        const size_t copyLength = min( (dataLength-numBytesRead), (size_t)bytesAvailable );
-        memcpy(output, m_uncompressedBlock.Buffer + m_blockOffset, copyLength);
-
-        // update counters
-        m_blockOffset += copyLength;
-        output        += copyLength;
-        numBytesRead  += copyLength;
-    }
-
-    // update block data
-    if ( m_blockOffset == m_blockLength ) {
-        m_blockAddress = m_device->Tell();
-        m_blockOffset  = 0;
-        m_blockLength  = 0;
-    }
-
-    // return actual number of bytes read
-    return numBytesRead;
-}
-
-// reads a BGZF block
-void BgzfStream::ReadBlock(void) {
-
-    BT_ASSERT_X( m_device, "BgzfStream::ReadBlock() - trying to read from null IO device");
-
-    // store block's starting address
-    const int64_t blockAddress = m_device->Tell();
-
-    // read block header from file
-    char header[Constants::BGZF_BLOCK_HEADER_LENGTH];
-    int64_t numBytesRead = m_device->Read(header, Constants::BGZF_BLOCK_HEADER_LENGTH);
-
-    // check for device error
-    if ( numBytesRead < 0 ) {
-        const string message = string("device error: ") + m_device->GetErrorString();
-        throw BamException("BgzfStream::ReadBlock", message);
-    }
-
-    // if block header empty
-    if ( numBytesRead == 0 ) {
-        m_blockLength = 0;
-        return;
-    }
-
-    // if block header invalid size
-    if ( numBytesRead != static_cast<int8_t>(Constants::BGZF_BLOCK_HEADER_LENGTH) )
-        throw BamException("BgzfStream::ReadBlock", "invalid block header size");
-
-    // validate block header contents
-    if ( !BgzfStream::CheckBlockHeader(header) )
-        throw BamException("BgzfStream::ReadBlock", "invalid block header contents");
-
-    // copy header contents to compressed buffer
-    const size_t blockLength = BamTools::UnpackUnsignedShort(&header[16]) + 1;
-    memcpy(m_compressedBlock.Buffer, header, Constants::BGZF_BLOCK_HEADER_LENGTH);
-
-    // read remainder of block
-    const size_t remaining = blockLength - Constants::BGZF_BLOCK_HEADER_LENGTH;
-    numBytesRead = m_device->Read(&m_compressedBlock.Buffer[Constants::BGZF_BLOCK_HEADER_LENGTH], remaining);
-
-    // check for device error
-    if ( numBytesRead < 0 ) {
-        const string message = string("device error: ") + m_device->GetErrorString();
-        throw BamException("BgzfStream::ReadBlock", message);
-    }
-
-    // check that we read in expected numBytes
-    if ( numBytesRead != static_cast<int64_t>(remaining) )
-        throw BamException("BgzfStream::ReadBlock", "could not read data from block");
-
-    // decompress block data
-    const size_t newBlockLength = InflateBlock(blockLength);
-
-    // update block data
-    if ( m_blockLength != 0 )
-        m_blockOffset = 0;
-    m_blockAddress = blockAddress;
-    m_blockLength  = newBlockLength;
-}
-
-// seek to position in BGZF file
-void BgzfStream::Seek(const int64_t& position) {
-
-    BT_ASSERT_X( m_device, "BgzfStream::Seek() - trying to seek on null IO device");
-
-    // skip if device is not open
-    if ( !IsOpen() ) return;
-
-    // determine adjusted offset & address
-    int     blockOffset  = (position & 0xFFFF);
-    int64_t blockAddress = (position >> 16) & 0xFFFFFFFFFFFFLL;
-
-    // attempt seek in file
-    if ( m_device->IsRandomAccess() && m_device->Seek(blockAddress) ) {
-
-        // update block data & return success
-        m_blockLength  = 0;
-        m_blockAddress = blockAddress;
-        m_blockOffset  = blockOffset;
-    }
-    else {
-        stringstream s("");
-        s << "unable to seek to position: " << position;
-        throw BamException("BgzfStream::Seek", s.str());
-    }
-}
-
-void BgzfStream::SetWriteCompressed(bool ok) {
-    m_isWriteCompressed = ok;
-}
-
-// get file position in BGZF file
-int64_t BgzfStream::Tell(void) const {
-    if ( !IsOpen() )
-        return 0;
-    return ( (m_blockAddress << 16) | (m_blockOffset & 0xFFFF) );
-}
-
-// writes the supplied data into the BGZF buffer
-size_t BgzfStream::Write(const char* data, const size_t dataLength) {
-
-    BT_ASSERT_X( m_device, "BgzfStream::Write() - trying to write to null IO device");
-    BT_ASSERT_X( (m_device->Mode() == IBamIODevice::WriteOnly),
-                 "BgzfStream::Write() - trying to write to non-writable IO device");
-
-    // skip if file not open for writing
-    if ( !IsOpen() )
-        return 0;
-
-    // write blocks as needed til all data is written
-    size_t numBytesWritten = 0;
-    const char* input = data;
-    const size_t blockLength = Constants::BGZF_DEFAULT_BLOCK_SIZE;
-    while ( numBytesWritten < dataLength ) {
-
-        // copy data contents to uncompressed output buffer
-        unsigned int copyLength = min(blockLength - m_blockOffset, dataLength - numBytesWritten);
-        char* buffer = m_uncompressedBlock.Buffer;
-        memcpy(buffer + m_blockOffset, input, copyLength);
-
-        // update counter
-        m_blockOffset   += copyLength;
-        input           += copyLength;
-        numBytesWritten += copyLength;
-
-        // flush (& compress) output buffer when full
-        if ( m_blockOffset == static_cast<int32_t>(blockLength) )
-            FlushBlock();
-    }
-
-    // return actual number of bytes written
-    return numBytesWritten;
-}
Index: bamtools/src/api/internal/io/pbgzf/block.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/block.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/block.h	(revision 43014)
@@ -0,0 +1,52 @@
+#ifndef BLOCK_H_
+#define BLOCK_H_
+
+typedef struct {
+    int8_t *buffer;
+    int32_t block_length;
+    int32_t block_offset; // used by bgzf_write and bgzf_flush
+    int64_t block_address; // used by bgzf_write and bgzf_flush
+    int64_t id; // Used by the queue
+    int32_t mem;
+} block_t;
+
+block_t*
+block_init();
+
+void
+block_destroy(block_t *block);
+
+typedef struct {
+    int32_t head;
+    int32_t n;
+    int32_t m;
+    block_t **blocks;
+    pthread_mutex_t *mut;
+} block_pool_t;
+
+// pool is full, with mutex
+block_pool_t*
+block_pool_init(int32_t m);
+
+// no blocks in the pool, no mutex
+block_pool_t*
+block_pool_init2(int32_t m);
+
+// add to the end of the queue
+int32_t
+block_pool_add(block_pool_t *pool, block_t *block);
+
+// get from the front of the queue
+block_t*
+block_pool_get(block_pool_t *pool);
+
+block_t*
+block_pool_peek(block_pool_t *pool);
+
+void
+block_pool_destroy(block_pool_t *pool);
+
+void
+block_pool_reset(block_pool_t *pool);
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/consumer.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/consumer.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/consumer.h	(revision 43014)
@@ -0,0 +1,35 @@
+#ifndef CONSUMER_H_
+#define CONSUMER_H_
+
+typedef struct {
+    queue_t *input;
+    queue_t *output;
+    reader_t *reader;
+    uint8_t *buffer;
+    int8_t is_done;
+    int8_t compress;
+    int32_t compress_level;
+    int32_t compress_type;
+    int16_t cid;
+    int64_t n;
+} consumer_t;
+
+consumer_t*
+consumer_init(queue_t *input,
+              queue_t *output,
+              reader_t *reader,
+              int8_t compress,
+              int32_t compress_level,
+              int32_t compress_type,
+              int32_t cid);
+
+void*
+consumer_run(void *arg);
+
+void
+consumer_destroy(consumer_t *c);
+
+void
+consumer_reset(consumer_t *c);
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/knetfile.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/knetfile.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/knetfile.c	(revision 43014)
@@ -0,0 +1,632 @@
+/* The MIT License
+
+   Copyright (c) 2008 by Genome Research Ltd (GRL).
+                 2010 by Attractive Chaos <attractor@live.co.uk>
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   "Software"), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be
+   included in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+   SOFTWARE.
+*/
+
+/* Probably I will not do socket programming in the next few years and
+   therefore I decide to heavily annotate this file, for Linux and
+   Windows as well.  -ac */
+
+#include <time.h>
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#ifndef _WIN32
+#include <netdb.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+#endif
+
+#include "knetfile.h"
+
+/* In winsock.h, the type of a socket is SOCKET, which is: "typedef
+ * u_int SOCKET". An invalid SOCKET is: "(SOCKET)(~0)", or signed
+ * integer -1. In knetfile.c, I use "int" for socket type
+ * throughout. This should be improved to avoid confusion.
+ *
+ * In Linux/Mac, recv() and read() do almost the same thing. You can see
+ * in the header file that netread() is simply an alias of read(). In
+ * Windows, however, they are different and using recv() is mandatory.
+ */
+
+/* This function tests if the file handler is ready for reading (or
+ * writing if is_read==0). */
+static int socket_wait(int fd, int is_read)
+{
+	fd_set fds, *fdr = 0, *fdw = 0;
+	struct timeval tv;
+	int ret;
+	tv.tv_sec = 5; tv.tv_usec = 0; // 5 seconds time out
+	FD_ZERO(&fds);
+	FD_SET(fd, &fds);
+	if (is_read) fdr = &fds;
+	else fdw = &fds;
+	ret = select(fd+1, fdr, fdw, 0, &tv);
+#ifndef _WIN32
+	if (ret == -1) perror("select");
+#else
+	if (ret == 0)
+		fprintf(stderr, "select time-out\n");
+	else if (ret == SOCKET_ERROR)
+		fprintf(stderr, "select: %d\n", WSAGetLastError());
+#endif
+	return ret;
+}
+
+#ifndef _WIN32
+/* This function does not work with Windows due to the lack of
+ * getaddrinfo() in winsock. It is addapted from an example in "Beej's
+ * Guide to Network Programming" (http://beej.us/guide/bgnet/). */
+static int socket_connect(const char *host, const char *port)
+{
+#define __err_connect(func) do { perror(func); freeaddrinfo(res); return -1; } while (0)
+
+	int on = 1, fd;
+	struct linger lng = { 0, 0 };
+	struct addrinfo hints, *res = 0;
+	memset(&hints, 0, sizeof(struct addrinfo));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	/* In Unix/Mac, getaddrinfo() is the most convenient way to get
+	 * server information. */
+	if (getaddrinfo(host, port, &hints, &res) != 0) __err_connect("getaddrinfo");
+	if ((fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1) __err_connect("socket");
+	/* The following two setsockopt() are used by ftplib
+	 * (http://nbpfaus.net/~pfau/ftplib/). I am not sure if they
+	 * necessary. */
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) == -1) __err_connect("setsockopt");
+	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, &lng, sizeof(lng)) == -1) __err_connect("setsockopt");
+	if (connect(fd, res->ai_addr, res->ai_addrlen) != 0) __err_connect("connect");
+	freeaddrinfo(res);
+	return fd;
+}
+#else
+/* MinGW's printf has problem with "%lld" */
+char *int64tostr(char *buf, int64_t x)
+{
+	int cnt;
+	int i = 0;
+	do {
+		buf[i++] = '0' + x % 10;
+		x /= 10;
+	} while (x);
+	buf[i] = 0;
+	for (cnt = i, i = 0; i < cnt/2; ++i) {
+		int c = buf[i]; buf[i] = buf[cnt-i-1]; buf[cnt-i-1] = c;
+	}
+	return buf;
+}
+
+int64_t strtoint64(const char *buf)
+{
+	int64_t x;
+	for (x = 0; *buf != '\0'; ++buf)
+		x = x * 10 + ((int64_t) *buf - 48);
+	return x;
+}
+/* In windows, the first thing is to establish the TCP connection. */
+int knet_win32_init()
+{
+	WSADATA wsaData;
+	return WSAStartup(MAKEWORD(2, 2), &wsaData);
+}
+void knet_win32_destroy()
+{
+	WSACleanup();
+}
+/* A slightly modfied version of the following function also works on
+ * Mac (and presummably Linux). However, this function is not stable on
+ * my Mac. It sometimes works fine but sometimes does not. Therefore for
+ * non-Windows OS, I do not use this one. */
+static SOCKET socket_connect(const char *host, const char *port)
+{
+#define __err_connect(func)										\
+	do {														\
+		fprintf(stderr, "%s: %d\n", func, WSAGetLastError());	\
+		return -1;												\
+	} while (0)
+
+	int on = 1;
+	SOCKET fd;
+	struct linger lng = { 0, 0 };
+	struct sockaddr_in server;
+	struct hostent *hp = 0;
+	// open socket
+	if ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET) __err_connect("socket");
+	if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(on)) == -1) __err_connect("setsockopt");
+	if (setsockopt(fd, SOL_SOCKET, SO_LINGER, (char*)&lng, sizeof(lng)) == -1) __err_connect("setsockopt");
+	// get host info
+	if (isalpha(host[0])) hp = gethostbyname(host);
+	else {
+		struct in_addr addr;
+		addr.s_addr = inet_addr(host);
+		hp = gethostbyaddr((char*)&addr, 4, AF_INET);
+	}
+	if (hp == 0) __err_connect("gethost");
+	// connect
+	server.sin_addr.s_addr = *((unsigned long*)hp->h_addr);
+	server.sin_family= AF_INET;
+	server.sin_port = htons(atoi(port));
+	if (connect(fd, (struct sockaddr*)&server, sizeof(server)) != 0) __err_connect("connect");
+	// freehostent(hp); // strangely in MSDN, hp is NOT freed (memory leak?!)
+	return fd;
+}
+#endif
+
+static off_t my_netread(int fd, void *buf, off_t len)
+{
+	off_t rest = len, curr, l = 0;
+	/* recv() and read() may not read the required length of data with
+	 * one call. They have to be called repeatedly. */
+	while (rest) {
+		if (socket_wait(fd, 1) <= 0) break; // socket is not ready for reading
+		curr = netread(fd, buf + l, rest);
+		/* According to the glibc manual, section 13.2, a zero returned
+		 * value indicates end-of-file (EOF), which should mean that
+		 * read() will not return zero if EOF has not been met but data
+		 * are not immediately available. */
+		if (curr == 0) break;
+		l += curr; rest -= curr;
+	}
+	return l;
+}
+
+/*************************
+ * FTP specific routines *
+ *************************/
+
+static int kftp_get_response(knetFile *ftp)
+{
+#ifndef _WIN32
+	unsigned char c;
+#else
+	char c;
+#endif
+	int n = 0;
+	char *p;
+	if (socket_wait(ftp->ctrl_fd, 1) <= 0) return 0;
+	while (netread(ftp->ctrl_fd, &c, 1)) { // FIXME: this is *VERY BAD* for unbuffered I/O
+		//fputc(c, stderr);
+		if (n >= ftp->max_response) {
+			ftp->max_response = ftp->max_response? ftp->max_response<<1 : 256;
+			ftp->response = realloc(ftp->response, ftp->max_response);
+		}
+		ftp->response[n++] = c;
+		if (c == '\n') {
+			if (n >= 4 && isdigit(ftp->response[0]) && isdigit(ftp->response[1]) && isdigit(ftp->response[2])
+				&& ftp->response[3] != '-') break;
+			n = 0;
+			continue;
+		}
+	}
+	if (n < 2) return -1;
+	ftp->response[n-2] = 0;
+	return strtol(ftp->response, &p, 0);
+}
+
+static int kftp_send_cmd(knetFile *ftp, const char *cmd, int is_get)
+{
+	if (socket_wait(ftp->ctrl_fd, 0) <= 0) return -1; // socket is not ready for writing
+	netwrite(ftp->ctrl_fd, cmd, strlen(cmd));
+	return is_get? kftp_get_response(ftp) : 0;
+}
+
+static int kftp_pasv_prep(knetFile *ftp)
+{
+	char *p;
+	int v[6];
+	kftp_send_cmd(ftp, "PASV\r\n", 1);
+	for (p = ftp->response; *p && *p != '('; ++p);
+	if (*p != '(') return -1;
+	++p;
+	sscanf(p, "%d,%d,%d,%d,%d,%d", &v[0], &v[1], &v[2], &v[3], &v[4], &v[5]);
+	memcpy(ftp->pasv_ip, v, 4 * sizeof(int));
+	ftp->pasv_port = (v[4]<<8&0xff00) + v[5];
+	return 0;
+}
+
+
+static int kftp_pasv_connect(knetFile *ftp)
+{
+	char host[80], port[10];
+	if (ftp->pasv_port == 0) {
+		fprintf(stderr, "[kftp_pasv_connect] kftp_pasv_prep() is not called before hand.\n");
+		return -1;
+	}
+	sprintf(host, "%d.%d.%d.%d", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
+	sprintf(port, "%d", ftp->pasv_port);
+	ftp->fd = socket_connect(host, port);
+	if (ftp->fd == -1) return -1;
+	return 0;
+}
+
+int kftp_connect(knetFile *ftp)
+{
+	ftp->ctrl_fd = socket_connect(ftp->host, ftp->port);
+	if (ftp->ctrl_fd == -1) return -1;
+	kftp_get_response(ftp);
+	kftp_send_cmd(ftp, "USER anonymous\r\n", 1);
+	kftp_send_cmd(ftp, "PASS kftp@\r\n", 1);
+	kftp_send_cmd(ftp, "TYPE I\r\n", 1);
+	return 0;
+}
+
+int kftp_reconnect(knetFile *ftp)
+{
+	if (ftp->ctrl_fd != -1) {
+		netclose(ftp->ctrl_fd);
+		ftp->ctrl_fd = -1;
+	}
+	netclose(ftp->fd);
+	ftp->fd = -1;
+	return kftp_connect(ftp);
+}
+
+// initialize ->type, ->host, ->retr and ->size
+knetFile *kftp_parse_url(const char *fn, const char *mode)
+{
+	knetFile *fp;
+	char *p;
+	int l;
+	if (strstr(fn, "ftp://") != fn) return 0;
+	for (p = (char*)fn + 6; *p && *p != '/'; ++p);
+	if (*p != '/') return 0;
+	l = p - fn - 6;
+	fp = calloc(1, sizeof(knetFile));
+	fp->type = KNF_TYPE_FTP;
+	fp->fd = -1;
+	/* the Linux/Mac version of socket_connect() also recognizes a port
+	 * like "ftp", but the Windows version does not. */
+	fp->port = strdup("21");
+	fp->host = calloc(l + 1, 1);
+	if (strchr(mode, 'c')) fp->no_reconnect = 1;
+	strncpy(fp->host, fn + 6, l);
+	fp->retr = calloc(strlen(p) + 8, 1);
+	sprintf(fp->retr, "RETR %s\r\n", p);
+    fp->size_cmd = calloc(strlen(p) + 8, 1);
+    sprintf(fp->size_cmd, "SIZE %s\r\n", p);
+	fp->seek_offset = 0;
+	return fp;
+}
+// place ->fd at offset off
+int kftp_connect_file(knetFile *fp)
+{
+	int ret;
+	long long file_size;
+	if (fp->fd != -1) {
+		netclose(fp->fd);
+		if (fp->no_reconnect) kftp_get_response(fp);
+	}
+	kftp_pasv_prep(fp);
+    kftp_send_cmd(fp, fp->size_cmd, 1);
+#ifndef _WIN32
+    if ( sscanf(fp->response,"%*d %lld", &file_size) != 1 )
+    {
+        fprintf(stderr,"[kftp_connect_file] %s\n", fp->response);
+        return -1;
+    }
+#else
+	const char *p = fp->response;
+	while (*p != ' ') ++p;
+	while (*p < '0' || *p > '9') ++p;
+	file_size = strtoint64(p);
+#endif
+	fp->file_size = file_size;
+	if (fp->offset>=0) {
+		char tmp[32];
+#ifndef _WIN32
+		sprintf(tmp, "REST %lld\r\n", (long long)fp->offset);
+#else
+		strcpy(tmp, "REST ");
+		int64tostr(tmp + 5, fp->offset);
+		strcat(tmp, "\r\n");
+#endif
+		kftp_send_cmd(fp, tmp, 1);
+	}
+	kftp_send_cmd(fp, fp->retr, 0);
+	kftp_pasv_connect(fp);
+	ret = kftp_get_response(fp);
+	if (ret != 150) {
+		fprintf(stderr, "[kftp_connect_file] %s\n", fp->response);
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	fp->is_ready = 1;
+	return 0;
+}
+
+
+/**************************
+ * HTTP specific routines *
+ **************************/
+
+knetFile *khttp_parse_url(const char *fn, const char *mode)
+{
+	knetFile *fp;
+	char *p, *proxy, *q;
+	int l;
+	if (strstr(fn, "http://") != fn) return 0;
+	// set ->http_host
+	for (p = (char*)fn + 7; *p && *p != '/'; ++p);
+	l = p - fn - 7;
+	fp = calloc(1, sizeof(knetFile));
+	fp->http_host = calloc(l + 1, 1);
+	strncpy(fp->http_host, fn + 7, l);
+	fp->http_host[l] = 0;
+	for (q = fp->http_host; *q && *q != ':'; ++q);
+	if (*q == ':') *q++ = 0;
+	// get http_proxy
+	proxy = getenv("http_proxy");
+	// set ->host, ->port and ->path
+	if (proxy == 0) {
+		fp->host = strdup(fp->http_host); // when there is no proxy, server name is identical to http_host name.
+		fp->port = strdup(*q? q : "80");
+		fp->path = strdup(*p? p : "/");
+	} else {
+		fp->host = (strstr(proxy, "http://") == proxy)? strdup(proxy + 7) : strdup(proxy);
+		for (q = fp->host; *q && *q != ':'; ++q);
+		if (*q == ':') *q++ = 0; 
+		fp->port = strdup(*q? q : "80");
+		fp->path = strdup(fn);
+	}
+	fp->type = KNF_TYPE_HTTP;
+	fp->ctrl_fd = fp->fd = -1;
+	fp->seek_offset = 0;
+	return fp;
+}
+
+int khttp_connect_file(knetFile *fp)
+{
+	int ret, l = 0;
+	char *buf, *p;
+	if (fp->fd != -1) netclose(fp->fd);
+	fp->fd = socket_connect(fp->host, fp->port);
+	buf = calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
+	l += sprintf(buf + l, "GET %s HTTP/1.0\r\nHost: %s\r\n", fp->path, fp->http_host);
+    l += sprintf(buf + l, "Range: bytes=%lld-\r\n", (long long)fp->offset);
+	l += sprintf(buf + l, "\r\n");
+	netwrite(fp->fd, buf, l);
+	l = 0;
+	while (netread(fp->fd, buf + l, 1)) { // read HTTP header; FIXME: bad efficiency
+		if (buf[l] == '\n' && l >= 3)
+			if (strncmp(buf + l - 3, "\r\n\r\n", 4) == 0) break;
+		++l;
+	}
+	buf[l] = 0;
+	if (l < 14) { // prematured header
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	ret = strtol(buf + 8, &p, 0); // HTTP return code
+	if (ret == 200 && fp->offset>0) { // 200 (complete result); then skip beginning of the file
+		off_t rest = fp->offset;
+		while (rest) {
+			off_t l = rest < 0x10000? rest : 0x10000;
+			rest -= my_netread(fp->fd, buf, l);
+		}
+	} else if (ret != 206 && ret != 200) {
+		free(buf);
+		fprintf(stderr, "[khttp_connect_file] fail to open file (HTTP code: %d).\n", ret);
+		netclose(fp->fd);
+		fp->fd = -1;
+		return -1;
+	}
+	free(buf);
+	fp->is_ready = 1;
+	return 0;
+}
+
+/********************
+ * Generic routines *
+ ********************/
+
+knetFile *knet_open(const char *fn, const char *mode)
+{
+	knetFile *fp = 0;
+	if (mode[0] != 'r') {
+		fprintf(stderr, "[kftp_open] only mode \"r\" is supported.\n");
+		return 0;
+	}
+	if (strstr(fn, "ftp://") == fn) {
+		fp = kftp_parse_url(fn, mode);
+		if (fp == 0) return 0;
+		if (kftp_connect(fp) == -1) {
+			knet_close(fp);
+			return 0;
+		}
+		kftp_connect_file(fp);
+	} else if (strstr(fn, "http://") == fn) {
+		fp = khttp_parse_url(fn, mode);
+		if (fp == 0) return 0;
+		khttp_connect_file(fp);
+	} else { // local file
+#ifdef _WIN32
+		/* In windows, O_BINARY is necessary. In Linux/Mac, O_BINARY may
+		 * be undefined on some systems, although it is defined on my
+		 * Mac and the Linux I have tested on. */
+		int fd = open(fn, O_RDONLY | O_BINARY);
+#else		
+		int fd = open(fn, O_RDONLY);
+#endif
+		if (fd == -1) {
+			perror("open");
+			return 0;
+		}
+		fp = (knetFile*)calloc(1, sizeof(knetFile));
+		fp->type = KNF_TYPE_LOCAL;
+		fp->fd = fd;
+		fp->ctrl_fd = -1;
+	}
+	if (fp && fp->fd == -1) {
+		knet_close(fp);
+		return 0;
+	}
+	return fp;
+}
+
+knetFile *knet_dopen(int fd, const char *mode)
+{
+	knetFile *fp = (knetFile*)calloc(1, sizeof(knetFile));
+	fp->type = KNF_TYPE_LOCAL;
+	fp->fd = fd;
+	return fp;
+}
+
+off_t knet_read(knetFile *fp, void *buf, off_t len)
+{
+	off_t l = 0;
+	if (fp->fd == -1) return 0;
+	if (fp->type == KNF_TYPE_FTP) {
+		if (fp->is_ready == 0) {
+			if (!fp->no_reconnect) kftp_reconnect(fp);
+			kftp_connect_file(fp);
+		}
+	} else if (fp->type == KNF_TYPE_HTTP) {
+		if (fp->is_ready == 0)
+			khttp_connect_file(fp);
+	}
+	if (fp->type == KNF_TYPE_LOCAL) { // on Windows, the following block is necessary; not on UNIX
+		off_t rest = len, curr;
+		while (rest) {
+			do {
+				curr = read(fp->fd, buf + l, rest);
+			} while (curr < 0 && EINTR == errno);
+			if (curr < 0) return -1;
+			if (curr == 0) break;
+			l += curr; rest -= curr;
+		}
+	} else l = my_netread(fp->fd, buf, len);
+	fp->offset += l;
+	return l;
+}
+
+off_t knet_seek(knetFile *fp, int64_t off, int whence)
+{
+	if (whence == SEEK_SET && off == fp->offset) return 0;
+	if (fp->type == KNF_TYPE_LOCAL) {
+		/* Be aware that lseek() returns the offset after seeking,
+		 * while fseek() returns zero on success. */
+		off_t offset = lseek(fp->fd, off, whence);
+		if (offset == -1) {
+            // Be silent, it is OK for knet_seek to fail when the file is streamed
+            // fprintf(stderr,"[knet_seek] %s\n", strerror(errno));
+			return -1;
+		}
+		fp->offset = offset;
+		return 0;
+	}
+    else if (fp->type == KNF_TYPE_FTP) 
+    {
+        if (whence==SEEK_CUR)
+            fp->offset += off;
+        else if (whence==SEEK_SET)
+            fp->offset = off;
+        else if ( whence==SEEK_END)
+            fp->offset = fp->file_size+off;
+		fp->is_ready = 0;
+		return 0;
+	} 
+    else if (fp->type == KNF_TYPE_HTTP) 
+    {
+		if (whence == SEEK_END) { // FIXME: can we allow SEEK_END in future?
+			fprintf(stderr, "[knet_seek] SEEK_END is not supported for HTTP. Offset is unchanged.\n");
+			errno = ESPIPE;
+			return -1;
+		}
+        if (whence==SEEK_CUR)
+            fp->offset += off;
+        else if (whence==SEEK_SET)
+            fp->offset = off;
+		fp->is_ready = 0;
+		return 0;
+	}
+	errno = EINVAL;
+    fprintf(stderr,"[knet_seek] %s\n", strerror(errno));
+	return -1;
+}
+
+int knet_close(knetFile *fp)
+{
+	if (fp == 0) return 0;
+	if (fp->ctrl_fd != -1) netclose(fp->ctrl_fd); // FTP specific
+	if (fp->fd != -1) {
+		/* On Linux/Mac, netclose() is an alias of close(), but on
+		 * Windows, it is an alias of closesocket(). */
+		if (fp->type == KNF_TYPE_LOCAL) close(fp->fd);
+		else netclose(fp->fd);
+	}
+	free(fp->host); free(fp->port);
+	free(fp->response); free(fp->retr); // FTP specific
+	free(fp->path); free(fp->http_host); // HTTP specific
+	free(fp);
+	return 0;
+}
+
+#ifdef KNETFILE_MAIN
+int main(void)
+{
+	char *buf;
+	knetFile *fp;
+	int type = 4, l;
+#ifdef _WIN32
+	knet_win32_init();
+#endif
+	buf = calloc(0x100000, 1);
+	if (type == 0) {
+		fp = knet_open("knetfile.c", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 1) { // NCBI FTP, large file
+		fp = knet_open("ftp://ftp.ncbi.nih.gov/1000genomes/ftp/data/NA12878/alignment/NA12878.chrom6.SLX.SRP000032.2009_06.bam", "r");
+		knet_seek(fp, 2500000000ll, SEEK_SET);
+		l = knet_read(fp, buf, 255);
+	} else if (type == 2) {
+		fp = knet_open("ftp://ftp.sanger.ac.uk/pub4/treefam/tmp/index.shtml", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 3) {
+		fp = knet_open("http://www.sanger.ac.uk/Users/lh3/index.shtml", "r");
+		knet_seek(fp, 1000, SEEK_SET);
+	} else if (type == 4) {
+		fp = knet_open("http://www.sanger.ac.uk/Users/lh3/ex1.bam", "r");
+		knet_read(fp, buf, 10000);
+		knet_seek(fp, 20000, SEEK_SET);
+		knet_seek(fp, 10000, SEEK_SET);
+		l = knet_read(fp, buf+10000, 10000000) + 10000;
+	}
+	if (type != 4 && type != 1) {
+		knet_read(fp, buf, 255);
+		buf[255] = 0;
+		printf("%s\n", buf);
+	} else write(fileno(stdout), buf, l);
+	knet_close(fp);
+	free(buf);
+	return 0;
+}
+#endif
Index: bamtools/src/api/internal/io/pbgzf/reader.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/reader.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/reader.c	(revision 43014)
@@ -0,0 +1,250 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "bgzf.h"
+#include "util.h"
+#include "block.h"
+#include "queue.h"
+#include "pbgzf.h"
+#include "reader.h"
+
+static const int WINDOW_SIZE = BGZF_MAX_BLOCK_SIZE;
+
+reader_t*
+reader_init(int fd, queue_t *input, uint8_t compress, block_pool_t *pool)
+{
+  reader_t *r = calloc(1, sizeof(reader_t));
+
+  if(0 == compress) {
+      r->fp_bgzf = bgzf_fdopen(fd, "r");
+  }
+  else {
+      r->fd_file = fd;
+  }
+  r->input = input;
+  r->compress = compress;
+  r->pool = pool;
+
+  return r;
+}
+
+static int
+reader_read_block(BGZF* fp, block_t *b)
+{
+  uint8_t header[BLOCK_HEADER_LENGTH];
+  int count, size = 0, remaining;
+  int64_t block_address = _bgzf_tell(fp->fp);
+  count = _bgzf_read(fp->fp, header, sizeof(header));
+  if (count == 0) {
+      fp->block_length = b->block_length = 0;
+      return 0;
+  }
+  size = count;
+  if (count != sizeof(header)) {
+      fprintf(stderr, "read failed\n");
+      return -1;
+  }
+  if (!bgzf_check_header(header)) {
+      fprintf(stderr, "invalid block header\n");
+      return -1;
+  }
+  b->block_length = unpackInt16((uint8_t*)&header[16]) + 1;
+  int8_t* compressed_block = (int8_t*) b->buffer;
+  memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
+  remaining = b->block_length - BLOCK_HEADER_LENGTH;
+  count = _bgzf_read(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
+  if (count != remaining) {
+      fprintf(stderr, "read failed\n");
+      return -1;
+  }
+  size += count;
+  /*
+  count = inflate_block(fp, block_length);
+  if (count < 0) return -1;
+  */
+  if (fp->block_length != 0) {
+      // Do not reset offset if this read follows a seek.
+      fp->block_offset = 0;
+  }
+  fp->block_address = block_address;
+  b->block_address = block_address;
+  /*
+   // TODO: in the consumer, with a mutex
+  fp->block_length = count;
+  cache_block(fp, size);
+  */
+  return 0;
+}
+
+void*
+reader_run(void *arg)
+{
+  reader_t *r = (reader_t*)arg;
+  block_t *b = NULL;
+  int32_t wait;
+  uint64_t n = 0;
+  block_pool_t *pool;
+  
+  //fprintf(stderr, "reader staring\n");
+
+  pool = block_pool_init2(PBGZF_BLOCKS_POOL_NUM);
+
+  while(!r->is_done) {
+#ifdef PBGZF_USE_LOCAL_POOLS
+      // read block
+      while(pool->n < pool->m) {
+          if(NULL == r->pool || NULL == (b = block_pool_get(r->pool))) {
+              b = block_init(); 
+          }
+          if(0 == r->compress) {
+              if(reader_read_block(r->fp_bgzf, b) < 0) {
+                  fprintf(stderr, "reader reader_read_block: bug encountered\n");
+                  exit(1);
+              }
+          }
+          else { 
+              if((b->block_length = read(r->fd_file, b->buffer, WINDOW_SIZE)) < 0) {
+                  fprintf(stderr, "reader read: bug encountered\n");
+                  exit(1);
+              }
+          }
+          if(NULL == b || 0 == b->block_length) {
+              block_pool_add(r->pool, b);
+              b = NULL;
+              break;
+          }
+          if(0 == block_pool_add(pool, b)) {
+              fprintf(stderr, "reader block_pool_add: bug encountered\n");
+              exit(1);
+          }
+      }
+      //fprintf(stderr, "reader: read in pool->n=%d\n", pool->n);
+
+      if(0 == pool->n) {
+          break;
+      }
+
+      // add to the queue
+      while(0 < pool->n) {
+          b = block_pool_peek(pool);
+          if(NULL == b) {
+              fprintf(stderr, "reader block_pool_get: bug encountered\n");
+              exit(1);
+          }
+          wait = (pool->n == pool->m) ? 1 : 0; // NB: only wait if we cannot read in any more...
+          if(0 == queue_add(r->input, b, wait)) {
+              if(1 == wait) {
+                  if(QUEUE_STATE_OK == r->input->state) {
+                      fprintf(stderr, "reader queue_add: bug encountered\n");
+                      exit(1);
+                  }
+                  else if(QUEUE_STATE_EOF == r->input->state) { // EOF, quit
+                      break;
+                  }
+                  else {
+                      // NB: if the reader has blocks, it does not make sense to
+                      // flush
+                      fprintf(stderr, "reader queue_add: bug encountered\n");
+                      exit(1);
+                  }
+              }
+              else {
+                  break;
+              }
+          }
+          block_pool_get(pool); // ignore return
+          b = NULL;
+          n++;
+      }
+      //fprintf(stderr, "reader: add to pool->n=%d\n", pool->n);
+      //fprintf(stderr, "r->output->n=%d\n", r->input->n);
+#else
+      // read block
+      //fprintf(stderr, "Reader #%d read block\n", 0);
+      b = block_init(); 
+      if(0 == r->compress) {
+          if(reader_read_block(r->fp_bgzf, b) < 0) {
+              fprintf(stderr, "reader reader_read_block: bug encountered\n");
+              exit(1);
+          }
+      }
+      else { 
+          if((b->block_length = read(r->fd_file, b->buffer, WINDOW_SIZE)) < 0) {
+              fprintf(stderr, "reader read: bug encountered\n");
+              exit(1);
+          }
+      }
+      if(NULL == b || 0 == b->block_length) {
+          block_destroy(b);
+          b = NULL;
+          break;
+      }
+
+      // add to the queue
+      //fprintf(stderr, "Reader #%d add to queue\n", 0);
+      wait = 1;
+      if(0 == queue_add(r->input, b, wait)) {
+          if(1 == wait) {
+              if(QUEUE_STATE_OK == r->input->state) {
+                  fprintf(stderr, "reader queue_add: bug encountered\n");
+                  exit(1);
+              }
+              else if(QUEUE_STATE_EOF == r->input->state) { // EOF, quit
+                  block_destroy(b);
+                  b = NULL;
+                  break;
+              }
+              else {
+                  queue_wait_until_not_flush(r->input);
+                  continue;
+              }
+          }
+          else {
+              block_destroy(b);
+              b = NULL;
+              break;
+          }
+      }
+      b = NULL;
+      n++;
+      //fprintf(stderr, "reader read %llu blocks\n", n);
+#endif
+  }
+  block_destroy(b);
+  b = NULL;
+  
+  r->is_done = 1;
+  
+  // NB: EOF should be handled when the adder is removed
+  queue_remove_adder(r->input);
+  
+  //fprintf(stderr, "reader read %llu blocks\n", n);
+  //fprintf(stderr, "reader r->input->n=%d\n", r->input->n);
+  //fprintf(stderr, "reader r->input->state=%d QUEUE_STATE_EOF=%d\n", r->input->state, QUEUE_STATE_EOF);
+
+  block_pool_destroy(pool);
+
+  return arg;
+}
+
+void
+reader_destroy(reader_t *r)
+{
+  if(NULL == r) return;
+  if(0 == r->compress) {
+      if(bgzf_close(r->fp_bgzf) < 0) {
+          fprintf(stderr, "reader bgzf_close: bug encountered\n");
+          exit(1);
+      }
+  }
+  free(r);
+}
+
+void
+reader_reset(reader_t *r)
+{
+    r->is_done = r->is_closed = 0;
+}
Index: bamtools/src/api/internal/io/pbgzf/knetfile.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/knetfile.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/knetfile.h	(revision 43014)
@@ -0,0 +1,75 @@
+#ifndef KNETFILE_H
+#define KNETFILE_H
+
+#include <stdint.h>
+#include <fcntl.h>
+
+#ifndef _WIN32
+#define netread(fd, ptr, len) read(fd, ptr, len)
+#define netwrite(fd, ptr, len) write(fd, ptr, len)
+#define netclose(fd) close(fd)
+#else
+#include <winsock2.h>
+#define netread(fd, ptr, len) recv(fd, ptr, len, 0)
+#define netwrite(fd, ptr, len) send(fd, ptr, len, 0)
+#define netclose(fd) closesocket(fd)
+#endif
+
+// FIXME: currently I/O is unbuffered
+
+#define KNF_TYPE_LOCAL 1
+#define KNF_TYPE_FTP   2
+#define KNF_TYPE_HTTP  3
+
+typedef struct knetFile_s {
+	int type, fd;
+	int64_t offset;
+	char *host, *port;
+
+	// the following are for FTP only
+	int ctrl_fd, pasv_ip[4], pasv_port, max_response, no_reconnect, is_ready;
+	char *response, *retr, *size_cmd;
+	int64_t seek_offset; // for lazy seek
+    int64_t file_size;
+
+	// the following are for HTTP only
+	char *path, *http_host;
+} knetFile;
+
+#define knet_tell(fp) ((fp)->offset)
+#define knet_fileno(fp) ((fp)->fd)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef _WIN32
+	int knet_win32_init();
+	void knet_win32_destroy();
+#endif
+
+	knetFile *knet_open(const char *fn, const char *mode);
+
+	/* 
+	   This only works with local files.
+	 */
+	knetFile *knet_dopen(int fd, const char *mode);
+
+	/*
+	  If ->is_ready==0, this routine updates ->fd; otherwise, it simply
+	  reads from ->fd.
+	 */
+	off_t knet_read(knetFile *fp, void *buf, off_t len);
+
+	/*
+	  This routine only sets ->offset and ->is_ready=0. It does not
+	  communicate with the FTP server.
+	 */
+	off_t knet_seek(knetFile *fp, int64_t off, int whence);
+	int knet_close(knetFile *fp);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/reader.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/reader.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/reader.h	(revision 43014)
@@ -0,0 +1,26 @@
+#ifndef READER_H_
+#define READER_H_
+
+typedef struct {
+    BGZF *fp_bgzf;
+    int fd_file;
+    queue_t *input;
+    uint8_t is_done;
+    uint8_t is_closed;
+    uint8_t compress;
+    block_pool_t *pool;
+} reader_t;
+
+reader_t*
+reader_init(int fd, queue_t *input, uint8_t compress, block_pool_t *pool);
+
+void*
+reader_run(void *arg);
+
+void
+reader_destroy(reader_t *r);
+
+void
+reader_reset(reader_t *r);
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/pbgzf.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/pbgzf.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/pbgzf.c	(revision 43014)
@@ -0,0 +1,737 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <errno.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include "bgzf.h"
+#include "util.h"
+#include "block.h"
+#include "queue.h"
+#include "reader.h"
+#include "writer.h"
+#include "consumer.h"
+#include "pbgzf.h"
+
+static int32_t num_threads_per_pbgzf = -1;
+
+void
+pbgzf_set_num_threads_per(int32_t n)
+{
+  fprintf(stderr, "Setting the number of threads per PBGZF file handle to %d\n", n);
+  num_threads_per_pbgzf = n;
+}
+
+static consumers_t*
+consumers_init(int32_t n, queue_t *input, queue_t *output, reader_t *reader, 
+               int32_t compress, int32_t compress_level, int32_t compress_type)
+{
+  consumers_t *c = NULL;
+  int32_t i;
+
+  c = calloc(1, sizeof(consumers_t));
+  c->threads = calloc(n, sizeof(pthread_t));
+  c->n = n;
+  c->c = calloc(n, sizeof(consumer_t*));
+
+  for(i=0;i<n;i++) {
+      c->c[i] = consumer_init(input, output, reader, compress, compress_level, compress_type, i);
+  }
+
+  pthread_attr_init(&c->attr);
+  pthread_attr_setdetachstate(&c->attr, PTHREAD_CREATE_JOINABLE);
+
+  return c;
+}
+
+static void
+consumers_destroy(consumers_t *c)
+{
+  int32_t i;
+  free(c->threads);
+  for(i=0;i<c->n;i++) {
+      consumer_destroy(c->c[i]);
+  }
+  free(c->c);
+  free(c);
+}
+
+static void
+consumers_run(consumers_t *c)
+{
+  int32_t i;
+
+  for(i=0;i<c->n;i++) {
+      if(0 != pthread_create(&c->threads[i], &c->attr, consumer_run, c->c[i])) {
+          fprintf(stderr, "failed to create threads");
+          exit(1);
+      }
+  }
+}
+
+static void
+consumers_join(consumers_t *c)
+{
+  int32_t i;
+
+  for(i=0;i<c->n;i++) {
+      if(0 != pthread_join(c->threads[i], NULL)) {
+          fprintf(stderr, "failed to join threads");
+          exit(1);
+      }
+  }
+  // flush the output queue
+  if(QUEUE_STATE_OK == c->c[0]->output->state) c->c[0]->output->state = QUEUE_STATE_FLUSH;
+}
+
+static void
+consumers_reset(consumers_t *c)
+{
+  int32_t i;
+  for(i=0;i<c->n;i++) {
+      consumer_reset(c->c[i]);
+  }
+}
+
+static producer_t*
+producer_init(reader_t *r)
+{
+  producer_t *p;
+
+  p = calloc(1, sizeof(producer_t));
+  p->r = r;
+
+  pthread_attr_init(&p->attr);
+  pthread_attr_setdetachstate(&p->attr, PTHREAD_CREATE_JOINABLE);
+
+  return p;
+}
+
+static void
+producer_destroy(producer_t *p)
+{
+  free(p);
+}
+
+static void
+producer_run(producer_t *p)
+{
+  if(0 != pthread_create(&p->thread, &p->attr, reader_run, p->r)) {
+      fprintf(stderr, "failed to create threads");
+      exit(1);
+  }
+}
+
+static void
+producer_join(producer_t *p)
+{
+  if(0 != pthread_join(p->thread, NULL)) {
+      fprintf(stderr, "failed to join threads");
+      exit(1);
+  }
+  // close the input queue
+  // TODO: sync?
+  if(p->r->input->state == QUEUE_STATE_OK) p->r->input->state = QUEUE_STATE_FLUSH;
+}
+
+static void
+producer_reset(producer_t *p)
+{
+  reader_reset(p->r);
+}
+
+static outputter_t*
+outputter_init(writer_t *w)
+{
+  outputter_t *o;
+
+  o = calloc(1, sizeof(outputter_t));
+  o->w = w;
+
+  pthread_attr_init(&o->attr);
+  pthread_attr_setdetachstate(&o->attr, PTHREAD_CREATE_JOINABLE);
+
+  return o;
+}
+
+static void
+outputter_destroy(outputter_t *o)
+{
+  free(o);
+}
+
+static void
+outputter_run(outputter_t *o)
+{
+  if(0 != pthread_create(&o->thread, &o->attr, writer_run, o->w)) {
+      fprintf(stderr, "failed to create threads");
+      exit(1);
+  }
+}
+
+static void
+outputter_join(outputter_t *o)
+{
+  if(0 != pthread_join(o->thread, NULL)) {
+      fprintf(stderr, "failed to join threads");
+      exit(1);
+  }
+}
+
+static void
+outputter_reset(outputter_t *o)
+{
+  writer_reset(o->w);
+}
+
+static inline
+int
+pbgzf_min(int x, int y)
+{
+  return (x < y) ? x : y;
+}
+
+static void
+pbgzf_run(PBGZF *fp)
+{
+  if(NULL != fp->p) producer_run(fp->p);
+  if(NULL != fp->c) consumers_run(fp->c);
+  if(NULL != fp->o) outputter_run(fp->o);
+}
+
+static void
+pbgzf_join(PBGZF *fp)
+{
+  // join producer
+  if(NULL != fp->p) producer_join(fp->p);
+  else if(QUEUE_STATE_OK == fp->input->state) fp->input->state = QUEUE_STATE_FLUSH;
+
+  // wake, just in case
+  queue_wake_all(fp->input);
+  if('r' == fp->open_mode) {
+      queue_wake_all(fp->output);
+  }
+
+  // join the consumers
+  if(NULL != fp->c) consumers_join(fp->c);
+  else if(QUEUE_STATE_OK == fp->output->state) fp->output->state = QUEUE_STATE_FLUSH;
+
+  // wake just in case
+  queue_wake_all(fp->output);
+
+  // join the outputter
+  if(NULL != fp->o) outputter_join(fp->o);
+}
+
+static PBGZF*
+pbgzf_init(int fd, const char* __restrict mode)
+{
+  int i, compress_level = -1, compress_type = 0, is_write;
+  char open_mode;
+  PBGZF *fp = NULL;
+
+  // set compress_level
+  for (i = 0; mode[i]; ++i)
+    if (mode[i] >= '0' && mode[i] <= '9') break;
+  if (mode[i]) compress_level = (int)mode[i] - '0';
+  if (strchr(mode, 'u')) compress_level = 0;
+
+  // set read/write
+  if (strchr(mode, 'r') || strchr(mode, 'R')) { /* The reading mode is preferred. */
+      open_mode = 'r';
+      is_write = 0;
+  } else if (strchr(mode, 'w') || strchr(mode, 'W')) {
+      open_mode = 'w';
+      is_write = 1;
+  }
+  else {
+      return NULL;
+  }
+  
+  // set type
+#ifndef DISABLE_BZ2
+  if (strchr(mode, 'Z')) {
+      compress_type = 0;
+  } else if (strchr(mode, 'B')) {
+      compress_type = 1;
+      if (compress_level < 1) {
+          compress_type = 0; // switch to gz no compress mode
+          compress_level = 0;
+      }
+  }
+  else {
+      compress_type = 0;
+  }
+#endif
+
+  fp = calloc(1, sizeof(PBGZF));
+
+  // queues
+  fp->open_mode = open_mode;
+  fp->is_write = is_write;
+  if(num_threads_per_pbgzf <= 0) {
+      fp->num_threads = detect_cpus(); 
+  }
+  else {
+      fp->num_threads = num_threads_per_pbgzf;
+  }
+  fprintf(stderr, "%s with %d threads.\n", ('r' == open_mode) ? "Reading" : "Writing", fp->num_threads);
+  fp->queue_size = PBGZF_QUEUE_SIZE;
+  fp->input = queue_init(fp->queue_size, 0, 1, fp->num_threads);
+  fp->output = queue_init(fp->queue_size, 1, fp->num_threads, 1);
+
+  fp->pool = block_pool_init(PBGZF_BLOCKS_POOL_NUM);
+  fp->block = NULL;
+  fp->n_blocks = 0;
+
+  if('w' == open_mode) { // write to a compressed file
+      fp->r = NULL; // do not read
+      fp->p = NULL; // do not produce data
+      fp->c = consumers_init(fp->num_threads, fp->input, fp->output, fp->r, 1, compress_level, compress_type); // deflate/compress
+      fp->w = writer_init(fd, fp->output, 1, compress_level, compress_type, fp->pool); // write data
+      fp->o = outputter_init(fp->w);
+  }
+  else { // read from a compressed file
+      if(strchr(mode, 'u')) {// hidden functionality
+          fp->r = reader_init(fd, fp->input, 1, fp->pool); // read the uncompressed file
+          fp->p = producer_init(fp->r);
+          fp->c = consumers_init(fp->num_threads, fp->input, fp->output, fp->r, 2, compress_level, compress_type); // do nothing
+      }
+      else {
+          fp->r = reader_init(fd, fp->input, 0, fp->pool); // read the compressed file
+          fp->p = producer_init(fp->r);
+          fp->c = consumers_init(fp->num_threads, fp->input, fp->output, fp->r, 0, compress_level, compress_type); // inflate
+          fp->eof_ok = bgzf_check_EOF(fp->r->fp_bgzf);
+      }
+      fp->w = NULL;
+      fp->o = NULL; // do not write
+  }
+
+  pbgzf_run(fp);
+
+  return fp;
+}
+
+PBGZF* pbgzf_fdopen(int fd, const char* __restrict mode)
+{
+  return pbgzf_init(fd, mode);
+}
+
+PBGZF* pbgzf_open(const char* path, const char* __restrict mode)
+{
+  int fd;
+  if (strchr(mode, 'r') || strchr(mode, 'R')) { /* The reading mode is preferred. */
+#ifdef _WIN32
+      fd = open(path, O_RDONLY | O_BINARY); 
+#else 
+      fd = open(path, O_RDONLY);
+#endif
+  }
+  else { // write to a compressed file
+#ifdef _WIN32
+      fd = open(path, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, 0666); 
+#else
+      fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0666); 
+#endif
+  }
+  if(-1 == fd) return NULL;
+  return pbgzf_fdopen(fd, mode);
+}
+
+int 
+pbgzf_read(PBGZF* fp, void* data, int length)
+{
+  if(length <= 0) {
+      return 0;
+  }
+  if(fp->open_mode != 'r') {
+      fprintf(stderr, "file not open for reading\n");
+      return -1;
+  }
+  if(fp->eof == 1) return 0;
+
+  int bytes_read = 0, available = 0;
+  int8_t* output = data;
+  while(bytes_read < length) {
+      int copy_length;
+
+      available = (NULL == fp->block) ? 0 : (fp->block->block_length - fp->block->block_offset);
+      if(0 == available) {
+          if(NULL != fp->block) {
+              block_destroy(fp->block);
+              fp->n_blocks++;
+          }
+          fp->block = queue_get(fp->output, 1);
+      }
+      available = (NULL == fp->block) ? 0 : (fp->block->block_length - fp->block->block_offset);
+      if(available <= 0) {
+          break;
+      }
+
+      int8_t *buffer;
+      copy_length = pbgzf_min(length-bytes_read, available);
+      buffer = (int8_t*)fp->block->buffer;
+      memcpy(output, buffer + fp->block->block_offset, copy_length);
+      fp->block->block_offset += copy_length;
+      output += copy_length;
+      bytes_read += copy_length;
+  }
+  // Try to get a new block and reset address/offset
+  if(NULL == fp->block || fp->block->block_offset == fp->block->block_length) {
+      if(NULL != fp->block) {
+          block_destroy(fp->block);
+          fp->block = NULL;
+          fp->n_blocks++;
+      }
+      if(0 < available) {
+          //fp->block = queue_get(fp->output, 1-fp->r->is_done);
+          // NB: do not wait if there will be no more data
+          fp->block = queue_get(fp->output, (QUEUE_STATE_EOF == fp->output->state) ? 0 : 1);
+      } // TODO: otherwise EOF?
+      if(NULL == fp->block) {
+          fp->block_offset = 0;
+          fp->block_address = bgzf_tell(fp->r->fp_bgzf);
+      }
+      else {
+          fp->block_offset = fp->block->block_offset;
+          fp->block_address = fp->block->block_address;
+      }
+  }
+  else {
+      fp->block_offset = fp->block->block_offset;
+      fp->block_address = fp->block->block_address;
+  }
+
+  if(0 == bytes_read) fp->eof = 1;
+
+  return bytes_read;
+}
+
+int 
+pbgzf_write(PBGZF* fp, const void* data, int length)
+{
+  const int8_t *input = data;
+  int block_length, bytes_written;
+
+  if(fp->open_mode != 'w') {
+      fprintf(stderr, "file not open for writing\n");
+      return -1;
+  }
+
+  if(NULL == fp->block) {
+      fp->block = block_init();
+      fp->block->block_length = BGZF_MAX_BLOCK_SIZE;
+  }
+
+  input = data;
+  block_length = fp->block->block_length;
+  bytes_written = 0;
+  while (bytes_written < length) {
+      int copy_length = pbgzf_min(block_length - fp->block->block_offset, length - bytes_written);
+      int8_t* buffer = fp->block->buffer;
+      memcpy(buffer + fp->block->block_offset, input, copy_length);
+      fp->block->block_offset += copy_length;
+      fp->block_offset += copy_length;
+      input += copy_length;
+      bytes_written += copy_length;
+      /*
+         fprintf(stderr, "fp->block_offset=%d copy_length=%d bytes_written=%d\n", 
+         fp->block_offset, copy_length, bytes_written);
+         */
+      if (fp->block->block_offset == block_length) {
+          // add to the queue
+          if(!queue_add(fp->input, fp->block, 1)) {
+              fprintf(stderr, "pbgzf_write queue_add: bug encountered\n");
+              exit(1);
+          }
+          fp->block = NULL;
+          fp->block = block_init();
+          fp->block_offset = 0;
+          fp->block->block_length = BGZF_MAX_BLOCK_SIZE;
+          fp->n_blocks++;
+      }
+  }
+  return bytes_written;
+}
+
+int64_t 
+pbgzf_tell(PBGZF *fp)
+{
+  if('w' == fp->open_mode) {
+      // wait until the input queue and output queue are empty
+      queue_wait_until_empty(fp->input);
+      queue_wait_until_empty(fp->output);
+      return bgzf_tell(fp->w->fp_bgzf);
+  }
+  else { // reading
+      return ((fp->block_address << 16) | (fp->block_offset & 0xFFFF));
+  }
+}
+
+int64_t 
+pbgzf_seek(PBGZF* fp, int64_t pos, int where)
+{
+  int32_t i;
+
+  if(fp->open_mode != 'r') {
+      fprintf(stderr, "file not open for read\n");
+      return -1;
+  }
+  if (where != SEEK_SET) {
+      fprintf(stderr, "unimplemented seek option\n");
+      return -1;
+  }
+
+  // signal and join
+  // signal other threads to finish
+  pthread_cond_signal(fp->input->not_full);
+  pthread_cond_signal(fp->input->not_empty);
+  if(NULL != fp->w) fp->w->is_done = 1;
+  if(NULL != fp->c) {
+      for(i=0;i<fp->c->n;i++) {
+          fp->c->c[i]->is_done = 1;
+      }
+  }
+  if(NULL != fp->r) fp->r->is_done = 1;
+
+  // join
+  pbgzf_join(fp);
+
+  // seek
+  if(bgzf_seek(fp->r->fp_bgzf, pos, where) < 0) {
+      return -1;
+  };
+
+  // reset the producer/consumer/outputter
+  if(NULL != fp->p) producer_reset(fp->p);
+  if(NULL != fp->c) consumers_reset(fp->c);
+  if(NULL != fp->o) outputter_reset(fp->o);
+
+  // reset the queues
+  queue_reset(fp->input, 1, fp->num_threads);
+  queue_reset(fp->output, fp->num_threads, 1);
+  
+  // restart threads
+  pbgzf_run(fp);
+
+  // get a block
+  if(NULL != fp->block) block_destroy(fp->block);
+  fp->block = queue_get(fp->output, 1);
+  if(NULL == fp->block) fp->eof = 1; // must be EOF
+  else fp->eof = 0;
+
+  // reset block offset/address
+  fp->block_offset = pos & 0xFFFF;
+  fp->block_address = (pos >> 16) & 0xFFFFFFFFFFFFLL;
+  if(NULL != fp->block) fp->block->block_offset = fp->block_offset;
+
+  return 0;
+}
+
+int 
+pbgzf_check_EOF(PBGZF *fp)
+{
+  if('r' != fp->open_mode) {
+      fprintf(stderr, "file not open for reading\n");
+      exit(1);
+  }
+  return fp->eof_ok;
+}
+
+static int 
+pbgzf_flush_aux(PBGZF* fp, int32_t restart)
+{
+  int ret;
+
+  if('w' != fp->open_mode) {
+      fprintf(stderr, "file not open for writing\n");
+      exit(1);
+  }
+
+  // flush
+  if(0 < fp->block->block_offset) {
+      fp->block->block_length = fp->block->block_offset;
+      if(!queue_add(fp->input, fp->block, 1)) {
+          fprintf(stderr, "pbgzf_flush_aux queue_add: bug encountered\n");
+          exit(1);
+      }
+      fp->block = NULL;
+
+      // wait until the input is empty
+      queue_wait_until_empty(fp->input);
+
+      // reset block
+      fp->block = block_init();
+      fp->block_offset = 0;
+      fp->block->block_length = BGZF_MAX_BLOCK_SIZE;
+  }
+  else {
+      // wait until the input is empty
+      queue_wait_until_empty(fp->input);
+  }
+
+  // close the input queue 
+  queue_close(fp->input);
+
+  // wake all
+  queue_wake_all(fp->input);
+
+  // join
+  pbgzf_join(fp);
+
+  // flush the underlying stream
+  ret = bgzf_flush(fp->w->fp_bgzf);
+  if(0 != ret) return ret;
+
+  if(1 == restart) {
+      // reset the producer/consumer/outputter
+      if(NULL != fp->p) producer_reset(fp->p);
+      if(NULL != fp->c) consumers_reset(fp->c);
+      if(NULL != fp->o) outputter_reset(fp->o);
+
+      // reset the queues
+      queue_reset(fp->input, 1, fp->num_threads);
+      queue_reset(fp->output, fp->num_threads, 1);
+
+      // restart threads
+      pbgzf_run(fp);
+  }
+
+  return 0;
+}
+
+int 
+pbgzf_flush(PBGZF* fp)
+{
+  return pbgzf_flush_aux(fp, 1);
+}
+
+int 
+pbgzf_flush_try(PBGZF *fp, int size)
+{
+  if (fp->block->block_offset + size > fp->block->block_length) { 
+      //NB: no need to restart the threads, just flush the current block
+
+      if('w' != fp->open_mode) {
+          fprintf(stderr, "file not open for writing\n");
+          exit(1);
+      }
+
+      // flush
+      if(0 < fp->block->block_offset) {
+          fp->block->block_length = fp->block->block_offset;
+          if(!queue_add(fp->input, fp->block, 1)) {
+              fprintf(stderr, "pbgzf_flush_try queue_add: bug encountered\n");
+              exit(1);
+          }
+          fp->block = NULL;
+
+          // reset block
+          fp->block = block_init();
+          fp->block_offset = 0;
+          fp->block->block_length = BGZF_MAX_BLOCK_SIZE;
+      }
+  }
+  return -1;
+}
+
+int 
+pbgzf_close(PBGZF* fp)
+{
+  int32_t i;
+  if(NULL == fp) return 0;
+  if('w' == fp->open_mode) {
+      // flush the data to the output file
+      pbgzf_flush_aux(fp, 0); // NB: no need to restart the threads
+  }
+  else {
+      // shut down the reader, regardless of where it is reading
+      fp->r->is_done = 1;
+
+      // shut down the consumers, regardless of what they are consuming
+      for(i=0;i<fp->c->n;i++) {
+          fp->c->c[i]->is_done = 1;
+      }
+  
+      // close the input queue
+      queue_close(fp->input); // NB: consumers should shut down when the input queue has EOF set
+      queue_close(fp->output); // NB: consumers should shut down when the input queue has EOF set
+
+      // wake all of the threads
+      queue_wake_all(fp->input);
+      queue_wake_all(fp->output);
+
+      // TODO: faster signal to the consumers that computation is complete
+      // join
+      pbgzf_join(fp);
+  }
+
+  // destroy
+  if(NULL != fp->c) consumers_destroy(fp->c);
+  if(NULL != fp->p) producer_destroy(fp->p);
+  if(NULL != fp->o) outputter_destroy(fp->o);
+  if(NULL != fp->input) queue_destroy(fp->input);
+  if(NULL != fp->output) queue_destroy(fp->output);
+  if(NULL != fp->r) reader_destroy(fp->r);
+  if(NULL != fp->w) writer_destroy(fp->w);
+
+  if(NULL != fp->block) block_destroy(fp->block);
+  fp->block = NULL;
+  block_pool_destroy(fp->pool);
+  free(fp);
+
+  return 0;
+}
+
+void pbgzf_set_cache_size(PBGZF *fp, int cache_size)
+{
+  if(fp && 'r' == fp->open_mode) bgzf_set_cache_size(fp->r->fp_bgzf, cache_size);
+}
+
+void
+pbgzf_main(int f_src, int f_dst, int compress, int compress_level, int compress_type, int queue_size, int num_threads)
+{
+  // NB: this gives us greater control over queue size and the like
+  queue_t *input = NULL;
+  queue_t *output = NULL;
+  reader_t *r = NULL;
+  writer_t *w = NULL;
+  consumers_t *c = NULL;
+  producer_t *p = NULL;
+  outputter_t *o = NULL;
+  block_pool_t *pool = NULL;
+
+  pool = block_pool_init(PBGZF_BLOCKS_POOL_NUM);
+  input = queue_init(queue_size, 0, 1, num_threads);
+  output = queue_init(queue_size, 1, num_threads, 1);
+
+  r = reader_init(f_src, input, compress, pool);
+  w = writer_init(f_dst, output, compress, compress_level, compress_type, pool);
+  c = consumers_init(num_threads, input, output, r, compress, compress_level, compress_type);
+  p = producer_init(r);
+  o = outputter_init(w);
+
+  producer_run(p);
+  consumers_run(c);
+  outputter_run(o);
+
+  producer_join(p);
+  consumers_join(c);
+  outputter_join(o);
+
+  consumers_destroy(c);
+  producer_destroy(p);
+  outputter_destroy(o);
+
+  queue_destroy(input);
+  queue_destroy(output);
+  reader_destroy(r);
+  writer_destroy(w);
+  block_pool_destroy(pool);
+}
Index: bamtools/src/api/internal/io/pbgzf/writer.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/writer.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/writer.c	(revision 43014)
@@ -0,0 +1,217 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "bgzf.h"
+#include "block.h"
+#include "queue.h"
+#include "pbgzf.h"
+#include "writer.h"
+
+writer_t*
+writer_init(int fd, queue_t *output, uint8_t compress, int32_t compress_level, int32_t compress_type, block_pool_t *pool)
+{
+  writer_t *w = calloc(1, sizeof(writer_t));
+
+  if(0 == compress) {
+      if(NULL == (w->fp_file = fdopen(fd, "wb"))) {
+          fprintf(stderr, "writer fdopen: bug encountered\n");
+          exit(1);
+      }
+  }
+  else {
+#ifndef DISABLE_BZ2
+      if (compress_type == 0) {
+          compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1
+      } else {
+          compress_level = compress_level < 1? BZ2_DEFAULT_LEVEL : compress_level; 
+      }
+#else
+      compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1
+#endif
+      char mode[3]="w";
+      if(0 <= compress_level) {
+          if(9 <= compress_level) compress_level = 9;
+          mode[1] = '0' + compress_level;
+          mode[2] = '\0';
+      }
+      if(NULL == (w->fp_bgzf = bgzf_fdopen(fd, mode))) {
+          fprintf(stderr, "writer open_write: bug encountered\n");
+          exit(1);
+      }
+      // NB: do not need w->fp_bgzf->compressed_block; 
+  }
+  w->output = output;
+  w->compress = compress;
+  w->pool_fp= pool;
+  w->pool_local = block_pool_init2(PBGZF_BLOCKS_POOL_NUM);
+
+  return w;
+}
+
+static size_t
+writer_write_block1(FILE* fp, block_t *b)
+{
+  return fwrite(b->buffer, sizeof(uint8_t), b->block_length, fp);
+}
+
+static size_t
+writer_write_block2(BGZF* fp, block_t *b)
+{
+  size_t count;
+  count = fwrite(b->buffer, 1, b->block_length, fp->fp);
+  if (count != b->block_length) {
+      fprintf(stderr, "writer fwrite: bug encountered\n");
+      return -1;
+  }
+  fp->block_offset = 0; // NB: important to update this!
+  fp->block_address += b->block_length;
+  return count;
+}
+
+void*
+writer_run(void *arg)
+{
+  writer_t *w = (writer_t*)arg;
+  block_t *b = NULL;
+  int32_t wait;
+  uint64_t n = 0;
+
+  //fprintf(stderr, "writer starting w->output->n=%d\n", w->output->n);
+  
+  while(!w->is_done) {
+#ifdef PBGZF_USE_LOCAL_POOLS
+      while(w->pool_local->n < w->pool_local->m) { // more to read from the output queue
+          wait = (0 == w->pool_local->n) ? 1 : 0;
+          b = queue_get(w->output, wait);
+          if(NULL == b) {
+              if(1 == wait) {
+                  if(QUEUE_STATE_OK == w->output->state) {
+                      fprintf(stderr, "writer queue_get: bug encountered\n");
+                      exit(1);
+                  }
+                  else if(QUEUE_STATE_EOF == w->output->state || 0 == w->output->num_adders) {
+                      break;
+                  }
+                  else {
+                      queue_wait_until_not_flush(w->output);
+                      continue;
+                  }
+              }
+              else {
+                  break;
+              }
+          }
+          if(0 == block_pool_add(w->pool_local, b)) {
+              fprintf(stderr, "writer block_pool_add: bug encountered\n");
+              exit(1);
+          }
+          b = NULL;
+      }
+      //fprintf(stderr, "writer: read from output w->pool_local->n=%d %d\n", w->pool_local->n, w->pool_local->m);
+
+      if(0 == w->pool_local->n && (QUEUE_STATE_EOF == w->output->state || 0 == w->output->num_adders)) {
+          break;
+      }
+
+      while(0 < w->pool_local->n) { // write all the blocks
+          b = block_pool_get(w->pool_local);
+          if(NULL == b) {
+              fprintf(stderr, "writer block_pool_get: bug encountered\n");
+              exit(1);
+          }
+          if(0 == w->compress) {
+              if(writer_write_block1(w->fp_file, b) != b->block_length) {
+                  fprintf(stderr, "writer writer_write_block: bug encountered\n");
+                  exit(1);
+              }
+          }
+          else {
+              if(writer_write_block2(w->fp_bgzf, b) != b->block_length) {
+                  fprintf(stderr, "writer writer_write_block: bug encountered\n");
+                  exit(1);
+              }
+          }
+          if(0 == block_pool_add(w->pool_fp, b)) {
+              fprintf(stderr, "writer block_pool_add: bug encountered\n");
+              exit(1);
+          }
+          n++;
+      }
+#else
+      wait = 1;
+      b = queue_get(w->output, wait);
+      if(NULL == b) {
+          if(1 == wait) {
+              if(QUEUE_STATE_OK == w->output->state) {
+                  fprintf(stderr, "writer queue_get: bug encountered\n");
+                  exit(1);
+              }
+              else if(QUEUE_STATE_EOF == w->output->state || 0 == w->output->num_adders) {
+                  break;
+              }
+              else {
+                  queue_wait_until_not_flush(w->output);
+                  continue;
+              }
+          }
+          else {
+              break;
+          }
+      }
+      if(0 == w->compress) {
+          if(writer_write_block1(w->fp_file, b) != b->block_length) {
+              fprintf(stderr, "writer writer_write_block: bug encountered\n");
+              exit(1);
+          }
+      }
+      else {
+          if(writer_write_block2(w->fp_bgzf, b) != b->block_length) {
+              fprintf(stderr, "writer writer_write_block: bug encountered\n");
+              exit(1);
+          }
+      }
+      block_destroy(b);
+      b = NULL;
+      n++;
+#endif
+  }
+
+  w->is_done = 1;
+  //fprintf(stderr, "writer written %llu blocks\n", n);
+
+  // NB: will wake all
+  queue_remove_getter(w->output);
+
+  return arg;
+}
+
+void
+writer_destroy(writer_t *w)
+{
+  if(NULL == w) return;
+  if(0 == w->compress) {
+      if(fclose(w->fp_file) < 0) {
+          fprintf(stderr, "writer bzf_close: bug encountered\n");
+          exit(1);
+      }
+  }
+  else {
+      if(bgzf_close(w->fp_bgzf) < 0) {
+          fprintf(stderr, "writer bzf_close: bug encountered\n");
+          exit(1);
+      }
+      // TODO
+  }
+  block_pool_destroy(w->pool_local);
+  free(w);
+}
+
+void
+writer_reset(writer_t *w)
+{
+  w->is_done = w->is_closed = 0;
+  block_pool_reset(w->pool_local);
+}
Index: bamtools/src/api/internal/io/pbgzf/pbgzf.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/pbgzf.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/pbgzf.h	(revision 43014)
@@ -0,0 +1,157 @@
+#ifndef PBGZF_H_
+#define PBGZF_H_
+
+#include <pthread.h>
+#include "bgzf.h"
+#include "block.h"
+#include "queue.h"
+#include "reader.h"
+#include "consumer.h"
+#include "writer.h"
+#include "util.h"
+
+#define DISABLE_BZ2
+
+#ifndef DISABLE_BZ2
+#define BZ2_DEFAULT_LEVEL 9
+#endif
+
+#ifdef __cplusplus 
+extern "C" {
+#endif
+
+typedef struct {
+    pthread_attr_t attr;
+    pthread_t *threads;
+    int32_t n;
+    consumer_t **c;
+} consumers_t;
+
+typedef struct {
+    pthread_attr_t attr;
+    pthread_t thread;
+    reader_t *r;
+} producer_t;
+
+typedef struct {
+    pthread_attr_t attr;
+    pthread_t thread;
+    writer_t *w;
+} outputter_t;
+
+typedef struct {
+    block_t *block; // buffer block
+    block_pool_t *pool;
+
+    char open_mode;
+    int32_t is_write;
+    int32_t queue_size;
+    int32_t num_threads;
+    int32_t block_offset; // for pbgzf_flush_tr
+    int64_t block_address; // for pbgzf_flush_tr
+    int32_t eof_ok; // for pbgzf_check_EOF
+    int32_t eof;
+    int64_t n_blocks;
+
+    queue_t *input;
+    queue_t *output;
+    reader_t *r;
+    writer_t *w;
+    consumers_t *c;
+    producer_t *p;
+    outputter_t *o;
+} PBGZF;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define PBGZF_QUEUE_SIZE 100
+#define PBGZF_BLOCKS_POOL_NUM 100
+//#define PBGZF_USE_LOCAL_POOLS 
+
+/*
+ * Sets the number of consumer threads per file handle.  If set to
+ * X, the numebr of threads will be X+1, due to the need to have a 
+ * single reader or writer thread in addition to the consumer 
+ * thread(s).
+ */
+void
+pbgzf_set_num_threads_per(int32_t n);
+
+/*
+ * Open an existing file descriptor for reading or writing.
+ * Mode must be either "r" or "w".
+ * A subsequent pbgzf_close will not close the file descriptor.
+ * Returns null on error.
+ */
+PBGZF* pbgzf_fdopen(int fd, const char* __restrict mode);
+
+/*
+ * Open the specified file for reading or writing.
+ * Mode must be either "r" or "w".
+ * Returns null on error.
+ */
+PBGZF* pbgzf_open(const char* path, const char* __restrict mode);
+
+/*
+ * Close the BGZ file and free all associated resources.
+ * Does not close the underlying file descriptor if created with pbgzf_fdopen.
+ * Returns zero on success, -1 on error.
+ */
+int pbgzf_close(PBGZF* fp);
+
+/*
+ * Read up to length bytes from the file storing into data.
+ * Returns the number of bytes actually read.
+ * Returns zero on end of file.
+ * Returns -1 on error.
+ */
+int pbgzf_read(PBGZF* fp, void* data, int length);
+
+/*
+ * Write length bytes from data to the file.
+ * Returns the number of bytes written.
+ * Returns -1 on error.
+ */
+int pbgzf_write(PBGZF* fp, const void* data, int length);
+
+/*
+ * Return a virtual file pointer to the current location in the file.
+ * No interpetation of the value should be made, other than a subsequent
+ * call to pbgzf_seek can be used to position the file at the same point.
+ * Return value is non-negative on success.
+ * Returns -1 on error.
+ */
+int64_t pbgzf_tell(PBGZF *fp);
+
+/*
+ * Set the file to read from the location specified by pos, which must
+ * be a value previously returned by pbgzf_tell for this file (but not
+ * necessarily one returned by this file handle).
+ * The where argument must be SEEK_SET.
+ * Seeking on a file opened for write is not supported.
+ * Returns zero on success, -1 on error.
+ */
+int64_t pbgzf_seek(PBGZF* fp, int64_t pos, int where);
+
+int pbgzf_check_EOF(PBGZF *fp);
+
+int pbgzf_flush(PBGZF* fp);
+
+int pbgzf_flush_try(PBGZF *fp, int size);
+
+void pbgzf_set_cache_size(PBGZF *fp, int cache_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+void
+pbgzf_main(int f_src, int f_dst, int compress, int compress_level, int compress_type, int queue_size, int num_threads);
+
+#ifdef __cplusplus 
+}
+#endif
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/util.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/util.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/util.c	(revision 43014)
@@ -0,0 +1,106 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#if defined(__APPLE__)
+#include <sys/sysctl.h>
+#elif defined(_SC_NPROCESSORS_ONLN)
+#include <unistd.h>
+#endif
+
+inline void
+safe_mutex_lock(pthread_mutex_t *mutex)
+{
+  int ret = pthread_mutex_lock(mutex);
+  if(ret != 0) {
+      fprintf(stderr, "pthread_mutex_lock error [%d]! Aborting immediately!\n", ret);
+      exit(1);
+  }
+}
+
+inline void
+safe_mutex_unlock(pthread_mutex_t *mutex)
+{
+  int ret = pthread_mutex_unlock(mutex);
+  if(ret != 0) {
+      fprintf(stderr, "pthread_mutex_unlock error [%d]! Aborting immediately!\n", ret);
+      exit(1);
+  }
+}
+
+// from pbzip2 version 1.1.6 
+/*
+   This program, "pbzip2" is copyright (C) 2003-2011 Jeff Gilchrist.
+   All rights reserved.
+
+   The library "libbzip2" which pbzip2 uses, is copyright
+   (C) 1996-2008 Julian R Seward.  All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+
+   1. Redistributions of source code must retain the above copyright
+   notice, this list of conditions and the following disclaimer.
+
+   2. The origin of this software must not be misrepresented; you must
+   not claim that you wrote the original software.  If you use this
+   software in a product, an acknowledgment in the product
+   documentation would be appreciated but is not required.
+
+   3. Altered source versions must be plainly marked as such, and must
+   not be misrepresented as being the original software.
+
+   4. The name of the author may not be used to endorse or promote
+   products derived from this software without specific prior written
+   permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+   OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+   DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
+   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+   Jeff Gilchrist, Ottawa, Canada.
+   pbzip2@compression.ca
+   pbzip2 version 1.1.6 of Oct 30, 2011
+   */
+int32_t
+detect_cpus()
+{
+  int32_t ncpu;
+
+  // Set default to 1 in case there is no auto-detect
+  ncpu = 1;
+
+  // Autodetect the number of CPUs on a box, if available
+#if defined(__APPLE__)
+  size_t len = sizeof(ncpu);
+  int32_t mib[2];
+  mib[0] = CTL_HW;
+  mib[1] = HW_NCPU;
+  if (sysctl(mib, 2, &ncpu, &len, 0, 0) < 0 || len != sizeof(ncpu))
+    ncpu = 1;
+#elif defined(_SC_NPROCESSORS_ONLN)
+  ncpu = sysconf(_SC_NPROCESSORS_ONLN);
+#elif defined(WIN32)
+  SYSTEM_INFO si;
+  GetSystemInfo(&si);
+  ncpu = si.dwNumberOfProcessors;
+#else
+#warning "CPU autodection is disabled"
+#endif
+
+  // Ensure we have at least one processor to use
+  if (ncpu < 1)
+    ncpu = 1;
+
+  return ncpu;
+}
Index: bamtools/src/api/internal/io/pbgzf/writer.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/writer.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/writer.h	(revision 43014)
@@ -0,0 +1,28 @@
+#ifndef WRITER_H_
+#define WRITER_H_
+
+typedef struct {
+    BGZF *fp_bgzf;
+    FILE *fp_file;
+    queue_t *output;
+    uint8_t compress;
+    int32_t compress_type;
+    uint8_t is_done;
+    uint8_t is_closed;
+    block_pool_t *pool_fp;
+    block_pool_t *pool_local;
+} writer_t;
+
+writer_t*
+writer_init(int fd, queue_t *output, uint8_t compress, int32_t compress_level, int32_t compress_type, block_pool_t *pool);
+
+void*
+writer_run(void *arg);
+
+void
+writer_destroy(writer_t *w);
+
+void
+writer_reset(writer_t *w);
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/util.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/util.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/util.h	(revision 43014)
@@ -0,0 +1,13 @@
+#ifndef UTIL_H_
+#define UTIL_H_
+
+inline void
+safe_mutex_lock(pthread_mutex_t *mutex);
+
+inline void
+safe_mutex_unlock(pthread_mutex_t *mutex);
+
+int32_t
+detect_cpus();
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/queue.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/queue.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/queue.c	(revision 43014)
@@ -0,0 +1,351 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <pthread.h>
+
+#include "util.h"
+#include "block.h"
+#include "queue.h"
+
+static void
+queue_close_nolock(queue_t *q)
+{
+  if(QUEUE_STATE_EOF == q->state) return;
+  q->state = QUEUE_STATE_EOF;
+  pthread_cond_broadcast(q->not_full);
+  pthread_cond_broadcast(q->not_empty);
+}
+
+void
+queue_signal(queue_t *q)
+{
+  if(q->n < q->mem) pthread_cond_signal(q->not_full);
+  if(0 == q->n) pthread_cond_signal(q->is_empty);
+  if(0 < q->n) pthread_cond_signal(q->not_empty);
+}
+
+queue_t*
+queue_init(int32_t capacity, int8_t ordered, int32_t num_adders, int32_t num_getters)
+{
+  queue_t *q = calloc(1, sizeof(queue_t));
+
+  q->mem = capacity;
+  q->queue = calloc(q->mem, sizeof(block_t*));
+  q->ordered = ordered;
+
+  q->mut = calloc(1, sizeof(pthread_mutex_t));
+  q->not_full = calloc(1, sizeof(pthread_cond_t));
+  q->not_empty = calloc(1, sizeof(pthread_cond_t));
+  q->is_empty = calloc(1, sizeof(pthread_cond_t));
+  q->not_flush = calloc(1, sizeof(pthread_cond_t));
+  q->state = QUEUE_STATE_OK;
+  q->num_adders = num_adders;
+  q->num_getters = num_getters;
+#ifdef QUEUE_DEBUG
+  q->num_waiting[0] = 0;
+  q->num_waiting[1] = 0;
+  q->num_waiting[2] = 0;
+  q->num_waiting[3] = 0;
+#endif
+    
+  if(0 != pthread_mutex_init(q->mut, NULL)) {
+      fprintf(stderr, "Could not create mutex\n");
+      exit(1);
+  }
+  if(0 != pthread_cond_init(q->not_full, NULL)) {
+      fprintf(stderr, "Could not create condition\n");
+      exit(1);
+  }
+  if(0 != pthread_cond_init(q->not_empty, NULL)) {
+      fprintf(stderr, "Could not create condition\n");
+      exit(1);
+  }
+  if(0 != pthread_cond_init(q->is_empty, NULL)) {
+      fprintf(stderr, "Could not create condition\n");
+      exit(1);
+  }
+  if(0 != pthread_cond_init(q->not_flush, NULL)) {
+      fprintf(stderr, "Could not create condition\n");
+      exit(1);
+  }
+
+  return q;
+}
+
+int8_t
+queue_add(queue_t *q, block_t *b, int8_t wait)
+{
+  safe_mutex_lock(q->mut);
+  queue_signal(q);
+  if(0 == q->num_getters) { // no more getters
+      queue_close_nolock(q); // close
+      safe_mutex_unlock(q->mut);
+      return 0;
+  }
+  else if(0 == q->num_adders) { // then why are you adding?
+      queue_close_nolock(q);
+      safe_mutex_unlock(q->mut);
+      return 0;
+  }
+  while(q->n == q->mem) {
+      if(wait && QUEUE_STATE_OK == q->state) {
+#ifdef QUEUE_DEBUG
+          q->num_waiting[0]++;
+#endif
+          if(0 != pthread_cond_wait(q->not_full, q->mut)) {
+              fprintf(stderr, "Could not condition wait\n");
+              exit(1);
+          }
+#ifdef QUEUE_DEBUG
+          q->num_waiting[0]--;
+#endif
+      }
+      else {
+          if(0 == q->num_getters) queue_close_nolock(q);
+          queue_signal(q);
+          safe_mutex_unlock(q->mut);
+          return 0;
+      }
+  }
+  if(1 == q->ordered) {
+      while(q->id - q->n + q->mem <= b->id) {
+          if(wait && QUEUE_STATE_OK == q->state) {
+#ifdef QUEUE_DEBUG
+              q->num_waiting[1]++;
+#endif
+              queue_signal(q); // NB: important to signal in case a getter may open this slot 
+              if(0 != pthread_cond_wait(q->not_full, q->mut)) {
+                  fprintf(stderr, "Could not condition wait\n");
+                  exit(1);
+              }
+#ifdef QUEUE_DEBUG
+              q->num_waiting[1]--;
+#endif
+          }
+          else {
+              if(0 == q->num_getters) queue_close_nolock(q);
+              queue_signal(q);
+              safe_mutex_unlock(q->mut);
+              return 0;
+          }
+      }
+      if(NULL != q->queue[b->id % q->mem]) {
+          fprintf(stderr, "Overwritting an existing block\n");
+          exit(1);
+      }
+      q->queue[b->id % q->mem] = b;
+  }
+  else {
+      b->id = q->id;
+      q->id++;
+      q->queue[q->tail++] = b;
+      if(q->tail == q->mem) q->tail = 0;
+  }
+  q->n++;
+  queue_signal(q);
+  safe_mutex_unlock(q->mut);
+  return 1;
+}
+
+block_t*
+queue_get(queue_t *q, int8_t wait)
+{
+  block_t *b = NULL;
+  safe_mutex_lock(q->mut);
+  queue_signal(q);
+  if(0 == q->num_getters) { // then why are you getting
+      queue_close_nolock(q); // close the queue
+      safe_mutex_unlock(q->mut);
+      return NULL;
+  }
+  else if(0 == q->n && 0 == q->num_adders) { 
+      queue_close_nolock(q);
+      safe_mutex_unlock(q->mut);
+      return NULL;
+  }
+  while(0 == q->n) {
+      if(1 == wait && QUEUE_STATE_OK == q->state) {
+#ifdef QUEUE_DEBUG
+          q->num_waiting[2]++;
+#endif
+          if(0 != pthread_cond_wait(q->not_empty, q->mut)) {
+              fprintf(stderr, "Could not condition wait\n");
+              exit(1);
+          }
+#ifdef QUEUE_DEBUG
+          q->num_waiting[2]--;
+#endif
+      }
+      else {
+          if(0 == q->num_adders && 0 == q->n) queue_close_nolock(q); // close the queue
+          queue_signal(q);
+          safe_mutex_unlock(q->mut);
+          return NULL;
+      }
+  }
+  b = q->queue[q->head];
+  if(q->ordered) {
+      while(NULL == b) {
+          if(1 == wait && QUEUE_STATE_OK == q->state) {
+#ifdef QUEUE_DEBUG
+              q->num_waiting[3]++;
+#endif
+              queue_signal(q); // NB: important to signal as an adder may add to this slot
+              if(0 != pthread_cond_wait(q->not_empty, q->mut)) {
+                  fprintf(stderr, "Could not condition wait\n");
+                  exit(1);
+              }
+#ifdef QUEUE_DEBUG
+              q->num_waiting[3]--;
+#endif
+          }
+          else {
+              if(0 == q->num_adders && 0 == q->n) queue_close_nolock(q); // close the queue
+              queue_signal(q);
+              safe_mutex_unlock(q->mut);
+              return NULL;
+          }
+          b = q->queue[q->head];
+      }
+  }
+  q->queue[q->head++] = NULL;
+  if(q->head == q->mem) q->head = 0;
+  if(q->ordered) q->id++;
+  q->n--;
+  queue_signal(q);
+  safe_mutex_unlock(q->mut);
+  return b;
+}
+
+void
+queue_wait_until_empty(queue_t *q)
+{
+  safe_mutex_lock(q->mut);
+  if(0 < q->n) { // wait
+      if(0 != pthread_cond_wait(q->is_empty, q->mut)) {
+          fprintf(stderr, "Could not condition wait\n");
+          exit(1);
+      }
+  }
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_wait_until_not_flush(queue_t *q)
+{
+  safe_mutex_lock(q->mut);
+  if(QUEUE_STATE_FLUSH == q->state) { // wait
+      if(0 != pthread_cond_wait(q->not_flush, q->mut)) {
+          fprintf(stderr, "Could not condition wait\n");
+          exit(1);
+      }
+  }
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_remove_flush(queue_t *q)
+{
+  if(QUEUE_STATE_FLUSH != q->state) return;
+  safe_mutex_lock(q->mut);
+  q->state = QUEUE_STATE_OK;
+  pthread_cond_signal(q->not_flush);
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_close(queue_t *q)
+{
+  if(QUEUE_STATE_EOF == q->state) return;
+  safe_mutex_lock(q->mut);
+  queue_close_nolock(q);
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_reset(queue_t *q, int32_t num_adders, int32_t num_getters)
+{
+  int32_t i;
+  safe_mutex_lock(q->mut);
+  for(i=0;i<q->mem;i++) {
+      if(NULL != q->queue[i]) {
+          block_destroy(q->queue[i]);
+          q->queue[i] = NULL;
+      }
+  }
+  q->head = q->tail = q->n = 0;
+  q->id = 0;
+  q->state = QUEUE_STATE_OK;
+  q->num_adders = num_adders;
+  q->num_getters = num_getters;
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_destroy(queue_t *q)
+{
+  int32_t i;
+  if(NULL == q) return;
+  queue_close(q);
+  for(i=0;i<q->mem;i++) {
+      block_destroy(q->queue[i]);
+  }
+  free(q->queue);
+  free(q->mut);
+  free(q->not_full);
+  free(q->not_empty);
+  free(q->is_empty);
+  free(q->not_flush);
+  free(q);
+}
+
+static void
+queue_wake_all_no_lock(queue_t *q)
+{
+  if(0 == q->num_getters || (0 == q->num_adders && 0 == q->n)) {
+      q->state = QUEUE_STATE_EOF;
+  }
+  pthread_cond_signal(q->not_full);
+  pthread_cond_signal(q->not_empty);
+  pthread_cond_signal(q->is_empty);
+  pthread_cond_signal(q->not_flush);
+}
+
+void
+queue_wake_all(queue_t *q)
+{
+  safe_mutex_lock(q->mut);
+  queue_wake_all_no_lock(q);
+  safe_mutex_unlock(q->mut);
+}
+
+void 
+queue_remove_adder(queue_t *q)
+{
+  safe_mutex_lock(q->mut);
+  q->num_adders--;
+  if(0 == q->num_adders && 0 == q->n) queue_wake_all_no_lock(q);
+  safe_mutex_unlock(q->mut);
+}
+
+void 
+queue_remove_getter(queue_t *q)
+{
+  safe_mutex_lock(q->mut);
+  q->num_getters--;
+  if(0 == q->num_getters) queue_wake_all_no_lock(q);
+  safe_mutex_unlock(q->mut);
+}
+
+void
+queue_print_status(queue_t *q, FILE *fp)
+{
+    fprintf(fp, "QUEUE STATUS\n");
+    fprintf(fp, "mem=%d head=%d tail=%d n=%d length=%d id=%lld ordered=%d num_adders=%d num_getters=%d\n",
+            q->mem, q->head, q->tail, q->n, q->length, q->id, q->ordered, q->num_adders, q->num_getters);
+#ifdef QUEUE_DEBUG
+    fprintf(fp, "num_waiting=[%d,%d,%d,%d]\n", 
+            q->num_waiting[0], q->num_waiting[1],
+            q->num_waiting[2], q->num_waiting[3]);
+#endif
+}
Index: bamtools/src/api/internal/io/pbgzf/bgzf.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/bgzf.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/bgzf.c	(revision 43014)
@@ -0,0 +1,666 @@
+/* The MIT License
+
+   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
+                 2011 Attractive Chaos <attractor@live.co.uk>
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <assert.h>
+#include <pthread.h>
+#include <sys/types.h>
+#include "bgzf.h"
+
+
+/* BGZF/GZIP header (speciallized from RFC 1952; little endian):
+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+ | 31|139|  8|  4|              0|  0|255|      6| 66| 67|      2|BLK_LEN|
+ +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
+*/
+static const uint8_t g_magic[19] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\0\0";
+
+#ifdef BGZF_CACHE
+typedef struct {
+	int size;
+	uint8_t *block;
+	int64_t end_offset;
+} cache_t;
+#include "khash.h"
+KHASH_MAP_INIT_INT64(cache, cache_t)
+#endif
+
+inline void
+packInt16(uint8_t* buffer, uint16_t value)
+{
+	buffer[0] = value;
+	buffer[1] = value >> 8;
+}
+
+inline int 
+unpackInt16(const uint8_t *buffer)
+{
+	return buffer[0] | buffer[1] << 8;
+}
+
+inline void 
+packInt32(uint8_t *buffer, uint32_t value)
+{
+	buffer[0] = value;
+	buffer[1] = value >> 8;
+	buffer[2] = value >> 16;
+	buffer[3] = value >> 24;
+}
+
+static BGZF *bgzf_read_init()
+{
+	BGZF *fp;
+	fp = calloc(1, sizeof(BGZF));
+	fp->is_write = 0;
+	fp->uncompressed_block = malloc(BGZF_MAX_BLOCK_SIZE);
+	fp->compressed_block = malloc(BGZF_MAX_BLOCK_SIZE);
+#ifdef BGZF_CACHE
+	fp->cache = kh_init(cache);
+#endif
+	return fp;
+}
+
+static BGZF *bgzf_write_init(int compress_level) // compress_level==-1 for the default level
+{
+	BGZF *fp;
+	fp = calloc(1, sizeof(BGZF));
+	fp->is_write = 1;
+	fp->uncompressed_block = malloc(BGZF_MAX_BLOCK_SIZE);
+	fp->compressed_block = malloc(BGZF_MAX_BLOCK_SIZE);
+	fp->compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1
+	if (fp->compress_level > 9) fp->compress_level = Z_DEFAULT_COMPRESSION;
+	return fp;
+}
+// get the compress level from the mode string
+static int mode2level(const char *__restrict mode)
+{
+	int i, compress_level = -1;
+	for (i = 0; mode[i]; ++i)
+		if (mode[i] >= '0' && mode[i] <= '9') break;
+	if (mode[i]) compress_level = (int)mode[i] - '0';
+	if (strchr(mode, 'u')) compress_level = 0;
+	return compress_level;
+}
+
+BGZF *bgzf_open(const char *path, const char *mode)
+{
+	BGZF *fp = 0;
+	assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
+	if (strchr(mode, 'r') || strchr(mode, 'R')) {
+		_bgzf_file_t fpr;
+		if ((fpr = _bgzf_open(path, "r")) == 0) return 0;
+		fp = bgzf_read_init();
+		fp->fp = fpr;
+	} else if (strchr(mode, 'w') || strchr(mode, 'W')) {
+		FILE *fpw;
+		if ((fpw = fopen(path, "w")) == 0) return 0;
+		fp = bgzf_write_init(mode2level(mode));
+		fp->fp = fpw;
+	}
+	return fp;
+}
+
+BGZF *bgzf_dopen(int fd, const char *mode)
+{
+	BGZF *fp = 0;
+	assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
+	if (strchr(mode, 'r') || strchr(mode, 'R')) {
+		_bgzf_file_t fpr;
+		if ((fpr = _bgzf_dopen(fd, "r")) == 0) return 0;
+		fp = bgzf_read_init();
+		fp->fp = fpr;
+	} else if (strchr(mode, 'w') || strchr(mode, 'W')) {
+		FILE *fpw;
+		if ((fpw = fdopen(fd, "w")) == 0) return 0;
+		fp = bgzf_write_init(mode2level(mode));
+		fp->fp = fpw;
+	}
+	return fp;
+}
+
+int bgzf_compress(void *_dst, int *dlen, void *src, int slen, int level)
+{
+	uint32_t crc;
+	z_stream zs;
+	uint8_t *dst = (uint8_t*)_dst;
+
+	// compress the body
+	zs.zalloc = NULL; zs.zfree = NULL;
+	zs.next_in  = src;
+	zs.avail_in = slen;
+	zs.next_out = dst + BLOCK_HEADER_LENGTH;
+	zs.avail_out = *dlen - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
+	if (deflateInit2(&zs, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY) != Z_OK) return -1; // -15 to disable zlib header/footer
+	if (deflate(&zs, Z_FINISH) != Z_STREAM_END) return -1;
+	if (deflateEnd(&zs) != Z_OK) return -1;
+	*dlen = zs.total_out + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
+	// write the header
+	memcpy(dst, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block
+	packInt16(&dst[16], *dlen - 1); // write the compressed length; -1 to fit 2 bytes
+	// write the footer
+	crc = crc32(crc32(0L, NULL, 0L), src, slen);
+	packInt32((uint8_t*)&dst[*dlen - 8], crc);
+	packInt32((uint8_t*)&dst[*dlen - 4], slen);
+	return 0;
+}
+
+// Deflate the block in fp->uncompressed_block into fp->compressed_block. Also adds an extra field that stores the compressed block length.
+static int deflate_block(BGZF *fp, int block_length)
+{
+	int comp_size = BGZF_MAX_BLOCK_SIZE;
+	if (bgzf_compress(fp->compressed_block, &comp_size, fp->uncompressed_block, block_length, fp->compress_level) != 0) {
+		fp->errcode |= BGZF_ERR_ZLIB;
+		return -1;
+	}
+	fp->block_offset = 0;
+	return comp_size;
+}
+
+// Inflate the block in fp->compressed_block into fp->uncompressed_block
+static int inflate_block(BGZF* fp, int block_length)
+{
+	z_stream zs;
+	zs.zalloc = NULL;
+	zs.zfree = NULL;
+	zs.next_in = fp->compressed_block + 18;
+	zs.avail_in = block_length - 16;
+	zs.next_out = fp->uncompressed_block;
+	zs.avail_out = BGZF_MAX_BLOCK_SIZE;
+
+	if (inflateInit2(&zs, -15) != Z_OK) {
+		fp->errcode |= BGZF_ERR_ZLIB;
+		return -1;
+	}
+	if (inflate(&zs, Z_FINISH) != Z_STREAM_END) {
+		inflateEnd(&zs);
+		fp->errcode |= BGZF_ERR_ZLIB;
+		return -1;
+	}
+	if (inflateEnd(&zs) != Z_OK) {
+		fp->errcode |= BGZF_ERR_ZLIB;
+		return -1;
+	}
+	return zs.total_out;
+}
+
+int
+bgzf_check_header(const uint8_t* header)
+{
+	return (header[0] == 31 && header[1] == 139 && header[2] == 8 && (header[3] & 4) != 0
+			&& unpackInt16((uint8_t*)&header[10]) == 6
+			&& header[12] == 'B' && header[13] == 'C'
+			&& unpackInt16((uint8_t*)&header[14]) == 2);
+}
+
+#ifdef BGZF_CACHE
+static void free_cache(BGZF *fp)
+{
+	khint_t k;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	if (fp->is_write) return;
+	for (k = kh_begin(h); k < kh_end(h); ++k)
+		if (kh_exist(h, k)) free(kh_val(h, k).block);
+	kh_destroy(cache, h);
+}
+
+static int load_block_from_cache(BGZF *fp, int64_t block_address)
+{
+	khint_t k;
+	cache_t *p;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	k = kh_get(cache, h, block_address);
+	if (k == kh_end(h)) return 0;
+	p = &kh_val(h, k);
+	if (fp->block_length != 0) fp->block_offset = 0;
+	fp->block_address = block_address;
+	fp->block_length = p->size;
+	memcpy(fp->uncompressed_block, p->block, BGZF_MAX_BLOCK_SIZE);
+	_bgzf_seek(fp->fp, p->end_offset, SEEK_SET);
+	return p->size;
+}
+
+static void cache_block(BGZF *fp, int size)
+{
+	int ret;
+	khint_t k;
+	cache_t *p;
+	khash_t(cache) *h = (khash_t(cache)*)fp->cache;
+	if (BGZF_MAX_BLOCK_SIZE >= fp->cache_size) return;
+	if ((kh_size(h) + 1) * BGZF_MAX_BLOCK_SIZE > fp->cache_size) {
+		/* A better way would be to remove the oldest block in the
+		 * cache, but here we remove a random one for simplicity. This
+		 * should not have a big impact on performance. */
+		for (k = kh_begin(h); k < kh_end(h); ++k)
+			if (kh_exist(h, k)) break;
+		if (k < kh_end(h)) {
+			free(kh_val(h, k).block);
+			kh_del(cache, h, k);
+		}
+	}
+	k = kh_put(cache, h, fp->block_address, &ret);
+	if (ret == 0) return; // if this happens, a bug!
+	p = &kh_val(h, k);
+	p->size = fp->block_length;
+	p->end_offset = fp->block_address + size;
+	p->block = malloc(BGZF_MAX_BLOCK_SIZE);
+	memcpy(kh_val(h, k).block, fp->uncompressed_block, BGZF_MAX_BLOCK_SIZE);
+}
+#else
+static void free_cache(BGZF *fp) {}
+static int load_block_from_cache(BGZF *fp, int64_t block_address) {return 0;}
+static void cache_block(BGZF *fp, int size) {}
+#endif
+
+int bgzf_read_block(BGZF *fp)
+{
+	uint8_t header[BLOCK_HEADER_LENGTH], *compressed_block;
+	int count, size = 0, block_length, remaining;
+	int64_t block_address;
+	block_address = _bgzf_tell(fp->fp);
+	if (fp->cache_size && load_block_from_cache(fp, block_address)) return 0;
+	count = _bgzf_read(fp->fp, header, sizeof(header));
+	if (count == 0) { // no data read
+		fp->block_length = 0;
+		return 0;
+	}
+	if (count != sizeof(header) || !bgzf_check_header(header)) {
+		fp->errcode |= BGZF_ERR_HEADER;
+		return -1;
+	}
+	size = count;
+	block_length = unpackInt16((uint8_t*)&header[16]) + 1; // +1 because when writing this number, we used "-1"
+	compressed_block = (uint8_t*)fp->compressed_block;
+	memcpy(compressed_block, header, BLOCK_HEADER_LENGTH);
+	remaining = block_length - BLOCK_HEADER_LENGTH;
+	count = _bgzf_read(fp->fp, &compressed_block[BLOCK_HEADER_LENGTH], remaining);
+	if (count != remaining) {
+		fp->errcode |= BGZF_ERR_IO;
+		return -1;
+	}
+	size += count;
+	if ((count = inflate_block(fp, block_length)) < 0) return -1;
+	if (fp->block_length != 0) fp->block_offset = 0; // Do not reset offset if this read follows a seek.
+	fp->block_address = block_address;
+	fp->block_length = count;
+	cache_block(fp, size);
+	return 0;
+}
+
+ssize_t bgzf_read(BGZF *fp, void *data, ssize_t length)
+{
+	ssize_t bytes_read = 0;
+	uint8_t *output = data;
+	if (length <= 0) return 0;
+	assert(fp->is_write == 0);
+	while (bytes_read < length) {
+		int copy_length, available = fp->block_length - fp->block_offset;
+		uint8_t *buffer;
+		if (available <= 0) {
+			if (bgzf_read_block(fp) != 0) return -1;
+			available = fp->block_length - fp->block_offset;
+			if (available <= 0) break;
+		}
+		copy_length = length - bytes_read < available? length - bytes_read : available;
+		buffer = fp->uncompressed_block;
+		memcpy(output, buffer + fp->block_offset, copy_length);
+		fp->block_offset += copy_length;
+		output += copy_length;
+		bytes_read += copy_length;
+	}
+	if (fp->block_offset == fp->block_length) {
+		fp->block_address = _bgzf_tell(fp->fp);
+		fp->block_offset = fp->block_length = 0;
+	}
+	return bytes_read;
+}
+
+/***** BEGIN: multi-threading *****/
+
+typedef struct {
+	BGZF *fp;
+	struct mtaux_t *mt;
+	void *buf;
+	int i, errcode, toproc;
+} worker_t;
+
+typedef struct mtaux_t {
+	int n_threads, n_blks, curr, done;
+	volatile int proc_cnt;
+	void **blk;
+	int *len;
+	worker_t *w;
+	pthread_t *tid;
+	pthread_mutex_t lock;
+	pthread_cond_t cv;
+} mtaux_t;
+
+static int worker_aux(worker_t *w)
+{
+	int i, tmp, stop = 0;
+	// wait for condition: to process or all done
+	pthread_mutex_lock(&w->mt->lock);
+	while (!w->toproc && !w->mt->done)
+		pthread_cond_wait(&w->mt->cv, &w->mt->lock);
+	if (w->mt->done) stop = 1;
+	w->toproc = 0;
+	pthread_mutex_unlock(&w->mt->lock);
+	if (stop) return 1; // to quit the thread
+	w->errcode = 0;
+	for (i = w->i; i < w->mt->curr; i += w->mt->n_threads) {
+		int clen = BGZF_MAX_BLOCK_SIZE;
+		if (bgzf_compress(w->buf, &clen, w->mt->blk[i], w->mt->len[i], w->fp->compress_level) != 0)
+			w->errcode |= BGZF_ERR_ZLIB;
+		memcpy(w->mt->blk[i], w->buf, clen);
+		w->mt->len[i] = clen;
+	}
+	tmp = __sync_fetch_and_add(&w->mt->proc_cnt, 1);
+	return 0;
+}
+
+static void *mt_worker(void *data)
+{
+	while (worker_aux(data) == 0);
+	return 0;
+}
+
+int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks)
+{
+	int i;
+	mtaux_t *mt;
+	pthread_attr_t attr;
+	if (!fp->is_write || fp->mt || n_threads <= 1) return -1;
+	mt = calloc(1, sizeof(mtaux_t));
+	mt->n_threads = n_threads;
+	mt->n_blks = n_threads * n_sub_blks;
+	mt->len = calloc(mt->n_blks, sizeof(int));
+	mt->blk = calloc(mt->n_blks, sizeof(void*));
+	for (i = 0; i < mt->n_blks; ++i)
+		mt->blk[i] = malloc(BGZF_MAX_BLOCK_SIZE);
+	mt->tid = calloc(mt->n_threads, sizeof(pthread_t)); // tid[0] is not used, as the worker 0 is launched by the master
+	mt->w = calloc(mt->n_threads, sizeof(worker_t));
+	for (i = 0; i < mt->n_threads; ++i) {
+		mt->w[i].i = i;
+		mt->w[i].mt = mt;
+		mt->w[i].fp = fp;
+		mt->w[i].buf = malloc(BGZF_MAX_BLOCK_SIZE);
+	}
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+	pthread_mutex_init(&mt->lock, 0);
+	pthread_cond_init(&mt->cv, 0);
+	for (i = 1; i < mt->n_threads; ++i) // worker 0 is effectively launched by the master thread
+		pthread_create(&mt->tid[i], &attr, mt_worker, &mt->w[i]);
+	fp->mt = mt;
+	return 0;
+}
+
+static void mt_destroy(mtaux_t *mt)
+{
+	int i;
+	// signal all workers to quit
+	pthread_mutex_lock(&mt->lock);
+	mt->done = 1; mt->proc_cnt = 0;
+	pthread_cond_broadcast(&mt->cv);
+	pthread_mutex_unlock(&mt->lock);
+	for (i = 1; i < mt->n_threads; ++i) pthread_join(mt->tid[i], 0); // worker 0 is effectively launched by the master thread
+	// free other data allocated on heap
+	for (i = 0; i < mt->n_blks; ++i) free(mt->blk[i]);
+	for (i = 0; i < mt->n_threads; ++i) free(mt->w[i].buf);
+	free(mt->blk); free(mt->len); free(mt->w); free(mt->tid);
+	pthread_cond_destroy(&mt->cv);
+	pthread_mutex_destroy(&mt->lock);
+	free(mt);
+}
+
+static void mt_queue(BGZF *fp)
+{
+	mtaux_t *mt = (mtaux_t*)fp->mt;
+	assert(mt->curr < mt->n_blks); // guaranteed by the caller
+	memcpy(mt->blk[mt->curr], fp->uncompressed_block, fp->block_offset);
+	mt->len[mt->curr] = fp->block_offset;
+	fp->block_offset = 0;
+	++mt->curr;
+}
+
+static int mt_flush(BGZF *fp)
+{
+	int i;
+	mtaux_t *mt = (mtaux_t*)fp->mt;
+	if (fp->block_offset) mt_queue(fp); // guaranteed that assertion does not fail
+	// signal all the workers to compress
+	pthread_mutex_lock(&mt->lock);
+	for (i = 0; i < mt->n_threads; ++i) mt->w[i].toproc = 1;
+	mt->proc_cnt = 0;
+	pthread_cond_broadcast(&mt->cv);
+	pthread_mutex_unlock(&mt->lock);
+	// worker 0 is doing things here
+	worker_aux(&mt->w[0]);
+	// wait for all the threads to complete
+	while (mt->proc_cnt < mt->n_threads);
+	// dump data to disk
+	for (i = 0; i < mt->n_threads; ++i) fp->errcode |= mt->w[i].errcode;
+	for (i = 0; i < mt->curr; ++i)
+		if (fwrite(mt->blk[i], 1, mt->len[i], fp->fp) != mt->len[i])
+			fp->errcode |= BGZF_ERR_IO;
+	mt->curr = 0;
+	return 0;
+}
+
+static int mt_lazy_flush(BGZF *fp)
+{
+	mtaux_t *mt = (mtaux_t*)fp->mt;
+	if (fp->block_offset) mt_queue(fp);
+	if (mt->curr == mt->n_blks)
+		return mt_flush(fp);
+	return -1;
+}
+
+static ssize_t mt_write(BGZF *fp, const void *data, ssize_t length)
+{
+	const uint8_t *input = data;
+	ssize_t rest = length;
+	while (rest) {
+		int copy_length = BGZF_BLOCK_SIZE - fp->block_offset < rest? BGZF_BLOCK_SIZE - fp->block_offset : rest;
+		memcpy(fp->uncompressed_block + fp->block_offset, input, copy_length);
+		fp->block_offset += copy_length; input += copy_length; rest -= copy_length;
+		if (fp->block_offset == BGZF_BLOCK_SIZE) mt_lazy_flush(fp);
+	}
+	return length - rest;
+}
+
+/***** END: multi-threading *****/
+
+int bgzf_flush(BGZF *fp)
+{
+	if (!fp->is_write) return 0;
+	if (fp->mt) return mt_flush(fp);
+	while (fp->block_offset > 0) {
+		int block_length;
+		block_length = deflate_block(fp, fp->block_offset);
+		if (block_length < 0) return -1;
+		if (fwrite(fp->compressed_block, 1, block_length, fp->fp) != block_length) {
+			fp->errcode |= BGZF_ERR_IO; // possibly truncated file
+			return -1;
+		}
+		fp->block_address += block_length;
+	}
+	return 0;
+}
+
+int bgzf_flush_try(BGZF *fp, ssize_t size)
+{
+	if (fp->block_offset + size > BGZF_BLOCK_SIZE) {
+		if (fp->mt) return mt_lazy_flush(fp);
+		else return bgzf_flush(fp);
+	}
+	return -1;
+}
+
+ssize_t bgzf_write(BGZF *fp, const void *data, ssize_t length)
+{
+	const uint8_t *input = data;
+	int block_length = BGZF_BLOCK_SIZE, bytes_written = 0;
+	assert(fp->is_write);
+	if (fp->mt) return mt_write(fp, data, length);
+	while (bytes_written < length) {
+		uint8_t* buffer = fp->uncompressed_block;
+		int copy_length = block_length - fp->block_offset < length - bytes_written? block_length - fp->block_offset : length - bytes_written;
+		memcpy(buffer + fp->block_offset, input, copy_length);
+		fp->block_offset += copy_length;
+		input += copy_length;
+		bytes_written += copy_length;
+		if (fp->block_offset == block_length && bgzf_flush(fp)) break;
+	}
+	return bytes_written;
+}
+
+int bgzf_close(BGZF* fp)
+{
+	int ret, count, block_length;
+	if (fp == 0) return -1;
+	if (fp->is_write) {
+		if (bgzf_flush(fp) != 0) return -1;
+		fp->compress_level = -1;
+		block_length = deflate_block(fp, 0); // write an empty block
+		count = fwrite(fp->compressed_block, 1, block_length, fp->fp);
+		if (fflush(fp->fp) != 0) {
+			fp->errcode |= BGZF_ERR_IO;
+			return -1;
+		}
+		if (fp->mt) mt_destroy(fp->mt);
+	}
+	ret = fp->is_write? fclose(fp->fp) : _bgzf_close(fp->fp);
+	if (ret != 0) return -1;
+	free(fp->uncompressed_block);
+	free(fp->compressed_block);
+	free_cache(fp);
+	free(fp);
+	return 0;
+}
+
+void bgzf_set_cache_size(BGZF *fp, int cache_size)
+{
+	if (fp) fp->cache_size = cache_size;
+}
+
+int bgzf_check_EOF(BGZF *fp)
+{
+	static uint8_t magic[28] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0";
+	uint8_t buf[28];
+	off_t offset;
+        if(0 == fp->compress_level) return 1;
+	offset = _bgzf_tell(fp->fp);
+	if (_bgzf_seek(fp->fp, -28, SEEK_END) < 0) return 0;
+	_bgzf_read(fp->fp, buf, 28);
+	_bgzf_seek(fp->fp, offset, SEEK_SET);
+	return (memcmp(magic, buf, 28) == 0)? 1 : 0;
+}
+
+int64_t bgzf_seek(BGZF* fp, int64_t pos, int where)
+{
+	int block_offset;
+	int64_t block_address;
+
+	if (fp->is_write || where != SEEK_SET) {
+		fp->errcode |= BGZF_ERR_MISUSE;
+		return -1;
+	}
+	block_offset = pos & 0xFFFF;
+	block_address = pos >> 16;
+	if (_bgzf_seek(fp->fp, block_address, SEEK_SET) < 0) {
+		fp->errcode |= BGZF_ERR_IO;
+		return -1;
+	}
+	fp->block_length = 0;  // indicates current block has not been loaded
+	fp->block_address = block_address;
+	fp->block_offset = block_offset;
+	return 0;
+}
+
+int bgzf_is_bgzf(const char *fn)
+{
+	uint8_t buf[16];
+	int n;
+	_bgzf_file_t fp;
+	if ((fp = _bgzf_open(fn, "r")) == 0) return 0;
+	n = _bgzf_read(fp, buf, 16);
+	_bgzf_close(fp);
+	if (n != 16) return 0;
+	return memcmp(g_magic, buf, 16) == 0? 1 : 0;
+}
+
+int bgzf_getc(BGZF *fp)
+{
+	int c;
+	if (fp->block_offset >= fp->block_length) {
+		if (bgzf_read_block(fp) != 0) return -2; /* error */
+		if (fp->block_length == 0) return -1; /* end-of-file */
+	}
+	c = ((unsigned char*)fp->uncompressed_block)[fp->block_offset++];
+    if (fp->block_offset == fp->block_length) {
+        fp->block_address = _bgzf_tell(fp->fp);
+        fp->block_offset = 0;
+        fp->block_length = 0;
+    }
+	return c;
+}
+
+#ifndef kroundup32
+#define kroundup32(x) (--(x), (x)|=(x)>>1, (x)|=(x)>>2, (x)|=(x)>>4, (x)|=(x)>>8, (x)|=(x)>>16, ++(x))
+#endif
+
+int bgzf_getline(BGZF *fp, int delim, kstring_t *str)
+{
+	int l, state = 0;
+	unsigned char *buf = (unsigned char*)fp->uncompressed_block;
+	str->l = 0;
+	do {
+		if (fp->block_offset >= fp->block_length) {
+			if (bgzf_read_block(fp) != 0) { state = -2; break; }
+			if (fp->block_length == 0) { state = -1; break; }
+		}
+		for (l = fp->block_offset; l < fp->block_length && buf[l] != delim; ++l);
+		if (l < fp->block_length) state = 1;
+		l -= fp->block_offset;
+		if (str->l + l + 1 >= str->m) {
+			str->m = str->l + l + 2;
+			kroundup32(str->m);
+			str->s = (char*)realloc(str->s, str->m);
+		}
+		memcpy(str->s + str->l, buf + fp->block_offset, l);
+		str->l += l;
+		fp->block_offset += l + 1;
+		if (fp->block_offset >= fp->block_length) {
+			fp->block_address = _bgzf_tell(fp->fp);
+			fp->block_offset = 0;
+			fp->block_length = 0;
+		} 
+	} while (state == 0);
+	if (str->l == 0 && state < 0) return state;
+	str->s[str->l] = 0;
+	return str->l;
+}
Index: bamtools/src/api/internal/io/pbgzf/queue.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/queue.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/queue.h	(revision 43014)
@@ -0,0 +1,88 @@
+#ifndef QUEUE_H_
+#define QUEUE_H_
+
+#define QUEUE_DEBUG
+
+enum {
+    QUEUE_STATE_OK = 0,
+    QUEUE_STATE_EOF = 1,
+    QUEUE_STATE_FLUSH = 2
+};
+
+typedef struct {
+    block_t **queue;
+    int32_t mem;
+    int32_t head;
+    int32_t tail;
+    int32_t n; 
+    int32_t length;
+    int64_t id;
+    int8_t ordered;
+    int32_t num_adders;
+    int32_t num_getters;
+    pthread_mutex_t *mut;
+    pthread_cond_t *not_full;
+    pthread_cond_t *not_empty;
+    pthread_cond_t *is_empty;
+    pthread_cond_t *not_flush;
+    int8_t state;
+#ifdef QUEUE_DEBUG
+    int32_t num_waiting[4];
+#endif
+} queue_t;
+
+queue_t*
+queue_init(int32_t capacity, int8_t ordered, int32_t num_adders, int32_t num_getters);
+
+int8_t
+queue_add(queue_t *q, block_t *b, int8_t wait);
+
+block_t*
+queue_get(queue_t *q, int8_t wait);
+
+void
+queue_signal(queue_t *q);
+
+// TODO
+/*
+int32_t
+queue_add_batch(queue_t *q, block_pool_t *pool, int8_t wait);
+
+int32_t
+queue_get_batch(queue_t *q, block_pool_t *pool, int8_t wait);
+*/
+
+void
+queue_wait_until_empty(queue_t *q);
+
+void
+queue_wait_until_not_flush(queue_t *q);
+
+#define queue_set_flush(_q) (_q->state = QUEUE_STATE_FLUSH)
+
+void
+queue_remove_flush(queue_t *q);
+
+void
+queue_close(queue_t *q);
+
+void
+queue_destroy(queue_t *q);
+
+void
+queue_reset(queue_t *q, int32_t num_adders, int32_t num_getters);
+
+void
+queue_wake_all(queue_t *q);
+
+void 
+queue_remove_adder(queue_t *q);
+
+void 
+queue_remove_getter(queue_t *q);
+
+// DEBUG
+void
+queue_print_status(queue_t *q, FILE *fp);
+
+#endif
Index: bamtools/src/api/internal/io/pbgzf/block.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/block.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/block.c	(revision 43014)
@@ -0,0 +1,152 @@
+#include <stdlib.h>
+#include <stdint.h>
+#include <pthread.h>
+#include "bgzf.h"
+#include "util.h"
+#include "block.h"
+
+block_t*
+block_init()
+{
+  block_t *b = calloc(1, sizeof(block_t));
+  b->buffer = malloc(sizeof(int8_t) * BGZF_MAX_BLOCK_SIZE);
+  b->id = -1;
+  return b;
+}
+
+void
+block_destroy(block_t *block)
+{
+  if(NULL == block) return;
+  free(block->buffer);
+  free(block);
+}
+
+block_pool_t*
+block_pool_init2(int32_t m)
+{
+  int32_t i;
+  block_pool_t *pool = calloc(1, sizeof(block_pool_t));
+
+  pool->m = m;
+  pool->n = 0;
+  pool->head = 0;
+  pool->blocks = calloc(pool->m, sizeof(block_pool_t*));
+  for(i=0;i<pool->m;i++) {
+      pool->blocks[i] = NULL;
+  }
+
+  return pool;
+}
+
+block_pool_t*
+block_pool_init(int32_t m)
+{
+  int32_t i;
+  block_pool_t *pool = NULL;
+
+  pool = block_pool_init2(m);
+  for(i=0;i<pool->m;i++) {
+      pool->blocks[i] = block_init();
+  }
+  pool->n = m;
+  
+  pool->mut = calloc(1, sizeof(pthread_mutex_t));
+  if(0 != pthread_mutex_init(pool->mut, NULL)) {
+      fprintf(stderr, "Could not create mutex\n");
+      exit(1);
+  }
+
+  return pool;
+}
+
+static void
+block_pool_shift(block_pool_t *pool)
+{
+  int32_t i;
+  /*
+  fprintf(stderr, "SHIFTING head=%d n=%d m=%d\n",
+          pool->head, pool->n, pool->m);
+          */
+  if(0 == pool->head) return;
+  for(i=0;i<pool->n;i++) {
+      pool->blocks[i] = pool->blocks[i+pool->head];
+      pool->blocks[i+pool->head] = NULL;
+  }
+  pool->head = 0;
+  /*
+  fprintf(stderr, "SHIFTED head=%d n=%d m=%d\n",
+          pool->head, pool->n, pool->m);
+          */
+}
+
+int32_t
+block_pool_add(block_pool_t *pool, block_t *block)
+{
+  if(NULL == block) return 0;
+  if(NULL != pool->mut) safe_mutex_lock(pool->mut);
+  if(pool->n < pool->m) {
+      if(pool->head + pool->n == pool->m) {
+          block_pool_shift(pool);
+      }
+      pool->blocks[pool->head+pool->n] = block;
+      pool->n++;
+  }
+  else { // ignore
+      block_destroy(block);
+  }
+  if(NULL != pool->mut) safe_mutex_unlock(pool->mut);
+  return 1;
+}
+
+block_t*
+block_pool_get(block_pool_t *pool)
+{
+  block_t *b = NULL;
+  if(NULL != pool->mut) safe_mutex_lock(pool->mut);
+  if(0 < pool->n) {
+      b = pool->blocks[pool->head];
+      pool->blocks[pool->head] = NULL;
+      pool->n--;
+      pool->head++;
+      if(pool->head == pool->m) pool->head = 0; // NB: pool->n == 0
+  }
+  if(NULL != pool->mut) safe_mutex_unlock(pool->mut);
+  return b;
+}
+
+block_t*
+block_pool_peek(block_pool_t *pool)
+{
+  block_t *b = NULL;
+  if(NULL != pool->mut) safe_mutex_lock(pool->mut);
+  if(0 < pool->n) {
+      b = pool->blocks[pool->head];
+  }
+  if(NULL != pool->mut) safe_mutex_unlock(pool->mut);
+  return b;
+}
+
+void
+block_pool_destroy(block_pool_t *pool)
+{
+  int32_t i;
+  if(NULL == pool) return;
+  for(i=0;i<pool->m;i++) {
+      block_destroy(pool->blocks[i]);
+  }
+  free(pool->blocks);
+  free(pool->mut);
+  free(pool);
+}
+
+void
+block_pool_reset(block_pool_t *pool)
+{
+  int32_t i;
+  for(i=0;i<pool->m;i++) {
+      block_destroy(pool->blocks[i]);
+      pool->blocks[i] = NULL;
+  }
+  pool->n = 0;
+}
Index: bamtools/src/api/internal/io/pbgzf/consumer.c
===================================================================
--- bamtools/src/api/internal/io/pbgzf/consumer.c	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/consumer.c	(revision 43014)
@@ -0,0 +1,416 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <string.h>
+#include <zlib.h>
+#ifndef DISABLE_BZ2
+#include <bzlib.h>
+#endif
+#include <pthread.h>
+
+#include "bgzf.h"
+#include "util.h"
+#include "block.h"
+#include "queue.h"
+#include "reader.h"
+#include "pbgzf.h"
+#include "consumer.h"
+
+#define GZIP_WINDOW_BITS -15 // no zlib header
+#define Z_DEFAULT_MEM_LEVEL 8
+
+consumer_t*
+consumer_init(queue_t *input,
+              queue_t *output,
+              reader_t *reader,
+              int8_t compress,
+              int32_t compress_level,
+              int32_t compress_type,
+              int32_t cid)
+{
+  consumer_t *c = calloc(1, sizeof(consumer_t));
+
+  c->input = input;
+  c->output = output;
+  c->reader = reader;
+  c->compress = compress;
+#ifndef DISABLE_BZ2
+  if (compress_type == 0) {
+#endif
+      c->compress_level = compress_level < 0? Z_DEFAULT_COMPRESSION : compress_level; // Z_DEFAULT_COMPRESSION==-1
+#ifndef DISABLE_BZ2
+  } else {
+      c->compress_level = compress_level < 1? BZ2_DEFAULT_LEVEL : compress_level; 
+  }
+#endif
+  c->compress_type = compress_type;
+  c->cid = cid;
+
+  c->buffer = malloc(sizeof(uint8_t)*BGZF_MAX_BLOCK_SIZE);
+
+  return c;
+}
+
+static int
+consumer_inflate_block_gz(consumer_t *c, block_t *block)
+{
+  z_stream zs;
+  int status;
+  
+  // copy compressed buffer into consumer buffer
+  memcpy(c->buffer, block->buffer, block->block_length);
+
+  zs.zalloc = NULL;
+  zs.zfree = NULL;
+  zs.next_in = c->buffer + 18;
+  zs.avail_in = block->block_length - 16;
+  zs.next_out = (void*)block->buffer;
+  zs.avail_out = BGZF_MAX_BLOCK_SIZE;
+
+  status = inflateInit2(&zs, GZIP_WINDOW_BITS);
+  if (status != Z_OK) {
+      fprintf(stderr, "inflate init failed\n");
+      return -1;
+  }
+
+  status = inflate(&zs, Z_FINISH);
+  if (status != Z_STREAM_END) {
+      inflateEnd(&zs);
+      fprintf(stderr, "inflate failed\n");
+      return -1;
+  }
+
+  status = inflateEnd(&zs);
+  if (status != Z_OK) {
+      fprintf(stderr, "inflate end failed\n");
+      return -1;
+  }
+
+  return zs.total_out;
+}
+
+#ifndef DISABLE_BZ2
+static int
+consumer_inflate_block_bz2(consumer_t *c, block_t *b)
+{
+  int32_t block_length;
+  int status;
+  unsigned int destLen;
+
+  memcpy(c->buffer, b->buffer, b->block_length); // copy uncompressed to compressed 
+  block_length = b->block_length;
+  
+  destLen = BGZF_MAX_BLOCK_SIZE;
+  status = BZ2_bzBuffToBuffDecompress((char*)b->buffer, &destLen, (char*)(c->buffer + 18), block_length-16, 0, 0); 
+  if (BZ_OK != status) {
+      // TODO: deal with BZ_OUTBUFF_FULL 
+      fprintf(stderr, "inflate failed\n");
+      return -1;
+  }
+  b->block_length = destLen;
+
+  return b->block_length;
+}
+#endif
+
+static int
+consumer_inflate_block(consumer_t *c, block_t *block)
+{
+#ifndef DISABLE_BZ2
+  // from bgzf.c
+  static uint8_t magic[28] = "\037\213\010\4\0\0\0\0\0\377\6\0\102\103\2\0\033\0\3\0\0\0\0\0\0\0\0\0";
+  static int32_t magic_l = 28;
+  if (0 == c->compress_type) return consumer_inflate_block_gz(c, block);
+  else if (magic_l == block->block_length) { // check EOF magic #...
+      if (0 != memcmp(magic, block->buffer, magic_l)) return consumer_inflate_block_bz2(c, block);
+      else return consumer_inflate_block_gz(c, block);
+  } else {
+      return consumer_inflate_block_bz2(c, block);
+  }
+#else
+  return consumer_inflate_block_gz(c, block);
+#endif
+}
+
+static int
+consumer_deflate_block_gz(consumer_t *c, block_t *b)
+{
+  // Deflate the block in fp->uncompressed_block into fp->compressed_block.
+  // Also adds an extra field that stores the compressed block length.
+  int32_t block_length;
+
+  memcpy(c->buffer, b->buffer, b->block_length); // copy uncompressed to compressed 
+
+  // Notes:
+  // fp->compressed_block is now b->buffer
+  // fp->uncompressed_block is now c->buffer
+  // block_length is now b->block_length
+  
+  block_length = b->block_length;
+  if(0 != bgzf_compress(b->buffer, &b->block_length, c->buffer, block_length, c->compress_level)) {
+      fprintf(stderr, "deflate failed\n");
+      return -1;
+  }
+  b->block_offset = 0;
+
+  return b->block_length;
+}
+
+#ifndef DISABLE_BZ2
+static int
+consumer_deflate_block_bz2(consumer_t *c, block_t *b)
+{
+  // Deflate the block in fp->uncompressed_block into fp->compressed_block.
+  // Also adds an extra field that stores the compressed block length.
+  int32_t block_length, compressed_length = 0;
+  int status, input_length;
+  unsigned int destLen;
+
+  memcpy(c->buffer, b->buffer, b->block_length); // copy uncompressed to compressed 
+  
+  // NB: use gzip header, for now...
+  consumer_init_header(b->buffer);
+
+  input_length = block_length = b->block_length;
+  destLen = BGZF_MAX_BLOCK_SIZE - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
+  while (1) {
+      status = BZ2_bzBuffToBuffCompress((char*)(b->buffer + BLOCK_HEADER_LENGTH), &destLen, (char*)c->buffer, input_length, 9, 0, 0); 
+      if (BZ_OK != status) {
+          if (status == BZ_OUTBUFF_FULL) {
+              // Not enough space in buffer.
+              // Can happen in the rare case the input doesn't compress enough.
+              // Reduce the amount of input until it fits.
+              input_length -= 1024;
+              if (input_length <= 0) {
+                  // should never happen
+                  fprintf(stderr, "input reduction failed\n");
+                  return -1;
+              }
+              continue;
+          }
+          fprintf(stderr, "deflate failed\n");
+          return -1;
+      }
+      break;
+  }
+  compressed_length = destLen;
+  compressed_length += BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
+  if (compressed_length > BGZF_MAX_BLOCK_SIZE) {
+      // should never happen
+      fprintf(stderr, "deflate overflow\n");
+      return -1;
+  }
+  b->block_length = compressed_length;
+  
+  consumer_update_header(c, b->buffer, input_length, compressed_length);
+
+  int remaining = block_length - input_length;
+  b->block_offset = remaining;
+  b->block_offset = 0;
+  
+  return compressed_length;
+}
+#endif
+
+static int
+consumer_deflate_block(consumer_t *c, block_t *b)
+{
+#ifndef DISABLE_BZ2
+  if(0 == c->compress_type) return consumer_deflate_block_gz(c, b);
+  else return consumer_deflate_block_bz2(c, b);
+#else
+  return consumer_deflate_block_gz(c, b);
+#endif
+}
+
+void*
+consumer_run(void *arg)
+{
+  consumer_t *c = (consumer_t*)arg;
+  block_t *b = NULL;
+  int32_t wait;
+  block_pool_t *pool_in = NULL, *pool_out = NULL;
+
+  pool_in = block_pool_init2(PBGZF_BLOCKS_POOL_NUM);
+  pool_out = block_pool_init2(PBGZF_BLOCKS_POOL_NUM);
+  c->n = 0;
+
+  //fprintf(stderr, "consumer #%d starting\n", c->cid);
+  //fprintf(stderr, "consumer start pool_in->n=%d\n", pool_in->n);
+  //fprintf(stderr, "consumer start pool_out->n=%d\n", pool_out->n);
+
+  while(1) {
+#ifdef PBGZF_USE_LOCAL_POOLS
+      // get block(s)
+      while(pool_in->n < pool_in->m) { // more to read in
+          b = queue_get(c->input, (0 == pool_in->n && 0 == pool_out->n) ? 1 : 0); // NB: only wait if the pools are empty
+          if(NULL == b) {
+              break;
+          }
+          //fprintf(stderr, "ADDING to pool_in b->id=%d\n", b->id);
+          if(0 == block_pool_add(pool_in, b)) {
+              fprintf(stderr, "consumer block_pool_add: bug encountered\n");
+              exit(1);
+          }
+          b = NULL;
+      }
+      //fprintf(stderr, "consumer get blocks pool_in->n=%d\n", pool_in->n);
+      //fprintf(stderr, "consumer get blocks pool_out->n=%d\n", pool_out->n);
+      if(0 == pool_in->n && 0 == pool_out->n) { // no more data
+          if(QUEUE_STATE_FLUSH == c->input->state) {
+              queue_wait_until_not_flush(c->input);
+              continue;
+          }
+          else if((NULL == c->reader && QUEUE_STATE_EOF == c->input->state) 
+             || (NULL != c->reader && 1 == c->reader->is_done)) { // TODO: does this need to be synced?
+              break;
+          }
+          else {
+              fprintf(stderr, "consumer queue_get: bug encountered\n");
+              exit(1);
+          }
+      }
+
+      // inflate/deflate
+      while(0 < pool_in->n && pool_out->n < pool_in->m) { // consume while the in has more and the out has room
+          b = block_pool_peek(pool_in);
+          //fprintf(stderr, "PEEK from pool_in b->id=%d\n", b->id);
+          if(NULL == b) {
+              fprintf(stderr, "consumer block_pool_get: bug encountered\n");
+              exit(1);
+          }
+          if(0 == c->compress) {
+              if((b->block_length = consumer_inflate_block(c, b)) < 0) {
+                  fprintf(stderr, "Error decompressing\n");
+                  exit(1);
+              }
+          }
+          else if(1 == c->compress) {
+              if((b->block_length = consumer_deflate_block(c, b)) < 0) {
+                  fprintf(stderr, "Error decompressing\n");
+                  exit(1);
+              }
+          }
+          if(0 == block_pool_add(pool_out, b)) {
+              fprintf(stderr, "consumer block_pool_add: bug encountered\n");
+              exit(1);
+          }
+          block_pool_get(pool_in); // ignore return
+          b = NULL;
+      }
+      //fprintf(stderr, "consumer inflate/deflate pool_in->n=%d\n", pool_in->n);
+      //fprintf(stderr, "consumer inflate/deflate pool_out->n=%d\n", pool_out->n);
+
+      // put back a block
+      while(0 < pool_out->n) {
+          b = block_pool_peek(pool_out);
+          // NB: only wait if the pools are full
+          wait = (pool_in->m == pool_in->n && pool_out->m == pool_out->n) ? 1 : 0;
+          if(!queue_add(c->output, b, wait)) {
+              if(1 == wait && QUEUE_STATE_EOF != c->output->state) {
+                  fprintf(stderr, "consumer queue_add: bug encountered\n");
+                  exit(1);
+              }
+              else {
+                  break;
+              }
+          }
+          block_pool_get(pool_out); // ignore return
+          b = NULL;
+          c->n++;
+      }
+      //fprintf(stderr, "consumer output pool_in->n=%d\n", pool_in->n);
+      //fprintf(stderr, "consumer output pool_out->n=%d\n", pool_out->n);
+      //fprintf(stderr, "consumer output c->output->n=%d\n", c->output->n);
+#else
+      // get block
+      //fprintf(stderr, "Consumer #%d get block\n", c->cid);
+      b = queue_get(c->input, 1);
+      if(NULL == b) {
+          if(QUEUE_STATE_FLUSH == c->input->state) {
+              queue_wait_until_not_flush(c->input);
+              continue;
+          }
+          else if((NULL == c->reader && QUEUE_STATE_EOF == c->input->state) 
+             || (NULL != c->reader && 1 == c->reader->is_done)) { // TODO: does this need to be synced?
+              break;
+          }
+          else {
+              fprintf(stderr, "consumer queue_get: bug encountered\n");
+              exit(1);
+          }
+      }
+
+      // inflate/deflate
+      //fprintf(stderr, "Consumer #%d inflate/deflate\n", c->cid);
+      if(0 == c->compress) {
+          if((b->block_length = consumer_inflate_block(c, b)) < 0) {
+              fprintf(stderr, "Error decompressing\n");
+              exit(1);
+          }
+      }
+      else if(1 == c->compress) {
+          if((b->block_length = consumer_deflate_block(c, b)) < 0) {
+              fprintf(stderr, "Error decompressing\n");
+              exit(1);
+          }
+      }
+
+      // put back a block
+      //fprintf(stderr, "Consumer #%d add block\n", c->cid);
+      wait = 1;
+      if(!queue_add(c->output, b, wait)) {
+          if(1 == wait && QUEUE_STATE_EOF != c->output->state) {
+              fprintf(stderr, "consumer queue_add: bug encountered\n");
+              exit(1);
+          }
+          else {
+              break;
+          }
+      }
+      b = NULL;
+      c->n++;
+#endif
+      
+      /*
+      fprintf(stderr, "consumer #%d c->input=[%d/%d,%d] c->output=[%d/%d,%d]\n",
+              c->cid,
+              c->input->n, c->input->mem, c->input->state,
+              c->output->n, c->output->mem, c->output->state);
+      */
+  }
+
+  c->is_done = 1;
+  // NB: queue handles waking...
+  queue_remove_getter(c->input);
+  queue_remove_adder(c->output);
+
+  //fprintf(stderr, "consumer #%d done processed %llu blocks\n", c->cid, c->n);
+  //queue_print_status(c->input, stderr);
+  //queue_print_status(c->output, stderr);
+
+  // TODO: why do you need to wake all here?
+  queue_wake_all(c->input);
+  queue_wake_all(c->output);
+
+  // destroy the pool
+  block_pool_destroy(pool_in);
+  block_pool_destroy(pool_out);
+
+  //fprintf(stderr, "consumer #%d exiting\n", c->cid);
+  return arg;
+}
+
+void
+consumer_destroy(consumer_t *c)
+{
+  if(NULL == c) return;
+  free(c->buffer);
+  free(c);
+}
+
+void
+consumer_reset(consumer_t *c)
+{
+  c->is_done = 0;
+}
Index: bamtools/src/api/internal/io/pbgzf/CMakeLists.txt
===================================================================
--- bamtools/src/api/internal/io/pbgzf/CMakeLists.txt	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/CMakeLists.txt	(revision 43014)
@@ -0,0 +1,33 @@
+# ==========================
+# BamTools CMakeLists.txt
+# (c) 2011 Derek Barnett
+#
+# src/api/internal/io/pbgzf
+# ==========================
+
+set ( InternalPBGZFDir "${InternalIODir}/pbgzf" )
+
+#--------------------------
+# platform-independent PBGZF
+#--------------------------
+set ( CommonPBGZFSources
+		${InternalPBGZFDir}/bgzf.c
+		${InternalPBGZFDir}/knetfile.c
+		${InternalPBGZFDir}/block.c
+		${InternalPBGZFDir}/consumer.c
+		${InternalPBGZFDir}/pbgzf.c
+		${InternalPBGZFDir}/queue.c
+		${InternalPBGZFDir}/reader.c
+		${InternalPBGZFDir}/util.c
+		${InternalPBGZFDir}/writer.c
+)
+
+#---------------------------
+# make build-specific list
+#---------------------------
+set ( InternalPBGZFSources 
+        ${CommonPBGZFSources} 
+
+        PARENT_SCOPE # <-- leave this last
+)
+
Index: bamtools/src/api/internal/io/pbgzf/bgzf.h
===================================================================
--- bamtools/src/api/internal/io/pbgzf/bgzf.h	(revision 0)
+++ bamtools/src/api/internal/io/pbgzf/bgzf.h	(revision 43014)
@@ -0,0 +1,251 @@
+/* The MIT License
+
+   Copyright (c) 2008 Broad Institute / Massachusetts Institute of Technology
+                 2011, 2012 Attractive Chaos <attractor@live.co.uk>
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+*/
+
+/* The BGZF library was originally written by Bob Handsaker from the Broad
+ * Institute. It was later improved by the SAMtools developers. */
+
+#ifndef __BGZF_H
+#define __BGZF_H
+
+#include <stdint.h>
+#include <stdio.h>
+#include <zlib.h>
+#include <sys/types.h>
+
+#define BGZF_BLOCK_SIZE     0xff00 // make sure compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE
+#define BGZF_MAX_BLOCK_SIZE 0x10000
+
+#define BLOCK_HEADER_LENGTH 18
+#define BLOCK_FOOTER_LENGTH 8
+
+#define BGZF_ERR_ZLIB   1
+#define BGZF_ERR_HEADER 2
+#define BGZF_ERR_IO     4
+#define BGZF_ERR_MISUSE 8
+
+#ifdef _USE_KNETFILE
+#include "knetfile.h"
+typedef knetFile *_bgzf_file_t;
+#define _bgzf_open(fn, mode) knet_open(fn, mode)
+#define _bgzf_dopen(fp, mode) knet_dopen(fp, mode)
+#define _bgzf_close(fp) knet_close((_bgzf_file_t)fp)
+#define _bgzf_fileno(fp) (((_bgzf_file_t)fp)->fd)
+#define _bgzf_tell(fp) knet_tell((_bgzf_file_t)fp)
+#define _bgzf_seek(fp, offset, whence) knet_seek((_bgzf_file_t)fp, offset, whence)
+#define _bgzf_read(fp, buf, len) knet_read((_bgzf_file_t)fp, buf, len)
+#define _bgzf_write(fp, buf, len) knet_write((_bgzf_file_t)fp, buf, len)
+#else // ~defined(_USE_KNETFILE)
+#if defined(_WIN32) || defined(_MSC_VER)
+#define ftello(fp) ftell((_bgzf_file_t)fp)
+#define fseeko(fp, offset, whence) fseek((_bgzf_file_t)fp, offset, whence)
+#else // ~defined(_WIN32)
+extern off_t ftello(FILE *stream);
+extern int fseeko(FILE *stream, off_t offset, int whence);
+#endif // ~defined(_WIN32)
+typedef FILE *_bgzf_file_t;
+#define _bgzf_open(fn, mode) fopen(fn, mode)
+#define _bgzf_dopen(fp, mode) fdopen(fp, mode)
+#define _bgzf_close(fp) fclose((_bgzf_file_t)fp)
+#define _bgzf_fileno(fp) fileno((_bgzf_file_t)fp)
+#define _bgzf_tell(fp) ftello((_bgzf_file_t)fp)
+#define _bgzf_seek(fp, offset, whence) fseeko((_bgzf_file_t)fp, offset, whence)
+#define _bgzf_read(fp, buf, len) fread(buf, 1, len, (_bgzf_file_t)fp)
+#define _bgzf_write(fp, buf, len) fwrite(buf, 1, len, (_bgzf_file_t)fp)
+#endif // ~define(_USE_KNETFILE)
+
+
+typedef struct {
+    int errcode:16, is_write:2, compress_level:14;
+    int cache_size;
+    int block_length, block_offset;
+    int64_t block_address;
+    void *uncompressed_block, *compressed_block;
+    void *cache; // a pointer to a hash table
+    void *fp; // actual file handler; FILE* on writing; FILE* or knetFile* on reading
+    void *mt; // only used for multi-threading
+} BGZF;
+
+#ifndef KSTRING_T
+#define KSTRING_T kstring_t
+typedef struct __kstring_t {
+	size_t l, m;
+	char *s;
+} kstring_t;
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+	/******************
+	 * Basic routines *
+	 ******************/
+
+	/**
+	 * Open an existing file descriptor for reading or writing.
+	 *
+	 * @param fd    file descriptor
+	 * @param mode  mode matching /[rwu0-9]+/: 'r' for reading, 'w' for writing and a digit specifies
+	 *              the zlib compression level; if both 'r' and 'w' are present, 'w' is ignored.
+	 * @return      BGZF file handler; 0 on error
+	 */
+	BGZF* bgzf_dopen(int fd, const char *mode);
+
+	#define bgzf_fdopen(fd, mode) bgzf_dopen((fd), (mode)) // for backward compatibility
+
+	/**
+	 * Open the specified file for reading or writing.
+	 */
+	BGZF* bgzf_open(const char* path, const char *mode);
+
+	/**
+	 * Close the BGZF and free all associated resources.
+	 *
+	 * @param fp    BGZF file handler
+	 * @return      0 on success and -1 on error
+	 */
+	int bgzf_close(BGZF *fp);
+
+	/**
+	 * Read up to _length_ bytes from the file storing into _data_.
+	 *
+	 * @param fp     BGZF file handler
+	 * @param data   data array to read into
+	 * @param length size of data to read
+	 * @return       number of bytes actually read; 0 on end-of-file and -1 on error
+	 */
+	ssize_t bgzf_read(BGZF *fp, void *data, ssize_t length);
+
+	/**
+	 * Write _length_ bytes from _data_ to the file.
+	 *
+	 * @param fp     BGZF file handler
+	 * @param data   data array to write
+	 * @param length size of data to write
+	 * @return       number of bytes actually written; -1 on error
+	 */
+	ssize_t bgzf_write(BGZF *fp, const void *data, ssize_t length);
+
+	/**
+	 * Write the data in the buffer to the file.
+	 */
+	int bgzf_flush(BGZF *fp);
+
+	/**
+	 * Return a virtual file pointer to the current location in the file.
+	 * No interpetation of the value should be made, other than a subsequent
+	 * call to bgzf_seek can be used to position the file at the same point.
+	 * Return value is non-negative on success.
+	 */
+	#define bgzf_tell(fp) ((fp->block_address << 16) | (fp->block_offset & 0xFFFF))
+
+	/**
+	 * Set the file to read from the location specified by _pos_.
+	 *
+	 * @param fp     BGZF file handler
+	 * @param pos    virtual file offset returned by bgzf_tell()
+	 * @param whence must be SEEK_SET
+	 * @return       0 on success and -1 on error
+	 */
+	int64_t bgzf_seek(BGZF *fp, int64_t pos, int whence);
+
+	/**
+	 * Check if the BGZF end-of-file (EOF) marker is present
+	 *
+	 * @param fp    BGZF file handler opened for reading
+	 * @return      1 if EOF is present; 0 if not or on I/O error
+	 */
+	int bgzf_check_EOF(BGZF *fp);
+
+	/**
+	 * Check if a file is in the BGZF format
+	 *
+	 * @param fn    file name
+	 * @return      1 if _fn_ is BGZF; 0 if not or on I/O error
+	 */
+	 int bgzf_is_bgzf(const char *fn);
+
+	/*********************
+	 * Advanced routines *
+	 *********************/
+
+	/**
+	 * Set the cache size. Only effective when compiled with -DBGZF_CACHE.
+	 *
+	 * @param fp    BGZF file handler
+	 * @param size  size of cache in bytes; 0 to disable caching (default)
+	 */
+	void bgzf_set_cache_size(BGZF *fp, int size);
+
+	/**
+	 * Flush the file if the remaining buffer size is smaller than _size_ 
+	 */
+	int bgzf_flush_try(BGZF *fp, ssize_t size);
+
+	/**
+	 * Read one byte from a BGZF file. It is faster than bgzf_read()
+	 * @param fp     BGZF file handler
+	 * @return       byte read; -1 on end-of-file or error
+	 */
+	int bgzf_getc(BGZF *fp);
+
+	/**
+	 * Read one line from a BGZF file. It is faster than bgzf_getc()
+	 *
+	 * @param fp     BGZF file handler
+	 * @param delim  delimitor
+	 * @param str    string to write to; must be initialized
+	 * @return       length of the string; 0 on end-of-file; negative on error
+	 */
+	int bgzf_getline(BGZF *fp, int delim, kstring_t *str);
+
+	/**
+	 * Read the next BGZF block.
+	 */
+	int bgzf_read_block(BGZF *fp);
+
+	/**
+	 * Enable multi-threading (only effective on writing)
+	 *
+	 * @param fp          BGZF file handler; must be opened for writing
+	 * @param n_threads   #threads used for writing
+	 * @param n_sub_blks  #blocks processed by each thread; a value 64-256 is recommended
+	 */
+	int bgzf_mt(BGZF *fp, int n_threads, int n_sub_blks);
+
+        inline void
+          packInt16(uint8_t* buffer, uint16_t value);
+        inline int
+          unpackInt16(const uint8_t* buffer);
+        inline void
+          packInt32(uint8_t* buffer, uint32_t value);
+        int
+          bgzf_check_header(const uint8_t* header);
+        int bgzf_compress(void *_dst, int *dlen, void *src, int slen, int level);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: bamtools/src/api/internal/io/SerialBgzfStream_p.h
===================================================================
--- bamtools/src/api/internal/io/SerialBgzfStream_p.h	(revision 0)
+++ bamtools/src/api/internal/io/SerialBgzfStream_p.h	(revision 43014)
@@ -0,0 +1,92 @@
+// ***************************************************************************
+// SerialBgzfStream_p.h (c) 2011 Derek Barnett
+// Marth Lab, Department of Biology, Boston College
+// ---------------------------------------------------------------------------
+// Last modified: 17 January 2012(DB)
+// ---------------------------------------------------------------------------
+// Based on BGZF routines developed at the Broad Institute.
+// Provides the basic functionality for reading & writing BGZF files
+// Replaces the old BGZF.* files to avoid clashing with other toolkits
+// ***************************************************************************
+
+#ifndef SERIALBGZFSTREAM_P_H
+#define SERIALBGZFSTREAM_P_H
+
+//  -------------
+//  W A R N I N G
+//  -------------
+//
+// This file is not part of the BamTools API.  It exists purely as an
+// implementation detail. This header file may change from version to version
+// without notice, or even be removed.
+//
+// We mean it.
+
+#include "api/api_global.h"
+#include "api/BamAux.h"
+#include "api/IBamIODevice.h"
+#include "api/internal/io/BgzfStream_p.h"
+#include <string>
+
+namespace BamTools {
+namespace Internal {
+
+class SerialBgzfStream : public BgzfStream {
+
+    // constructor & destructor
+    public:
+        SerialBgzfStream(void);
+        ~SerialBgzfStream(void);
+
+    // main interface methods
+    public:
+        // closes BGZF file
+        void Close(void);
+        // returns true if SerialBgzfStream open for IO
+        bool IsOpen(void) const;
+        // opens the BGZF file
+        void Open(const std::string& filename, const IBamIODevice::OpenMode mode);
+        // reads BGZF data into a byte buffer
+        size_t Read(char* data, const size_t dataLength);
+        // seek to position in BGZF file
+        void Seek(const int64_t& position);
+        // enable/disable compressed output
+        void SetWriteCompressed(bool ok);
+        // get file position in BGZF file
+        int64_t Tell(void) const;
+        // writes the supplied data into the BGZF buffer
+        size_t Write(const char* data, const size_t dataLength);
+
+    // internal methods
+    private:
+        // compresses the current block
+        size_t DeflateBlock(int32_t blockLength);
+        // flushes the data in the BGZF block
+        void FlushBlock(void);
+        // de-compresses the current block
+        size_t InflateBlock(const size_t& blockLength);
+        // reads a BGZF block
+        void ReadBlock(void);
+
+    // static 'utility' methods
+    public:
+        // checks BGZF block header
+        static bool CheckBlockHeader(char* header);
+
+    // data members
+    public:
+        int32_t m_blockLength;
+        int32_t m_blockOffset;
+        int64_t m_blockAddress;
+
+        bool m_isWriteCompressed;
+        IBamIODevice* m_device;
+
+        RaiiBuffer m_uncompressedBlock;
+        RaiiBuffer m_compressedBlock;
+};
+
+} // namespace Internal
+} // namespace BamTools
+
+#endif // SERIALBGZFSTREAM_P_H
Index: bamtools/src/api/internal/io/CMakeLists.txt
===================================================================
--- bamtools/src/api/internal/io/CMakeLists.txt	(revision 34298)
+++ bamtools/src/api/internal/io/CMakeLists.txt	(revision 43014)
@@ -7,6 +7,8 @@
 
 set ( InternalIODir "${InternalDir}/io" )
 
+add_subdirectory( pbgzf )
+
 #--------------------------
 # platform-independent IO
 #--------------------------
@@ -22,7 +24,9 @@
         ${InternalIODir}/HostInfo_p.cpp
         ${InternalIODir}/HttpHeader_p.cpp
         ${InternalIODir}/ILocalIODevice_p.cpp
+		${InternalIODir}/ParallelBgzfStream_p.cpp
         ${InternalIODir}/RollingBuffer_p.cpp
+		${InternalIODir}/SerialBgzfStream_p.cpp
         ${InternalIODir}/TcpSocket_p.cpp
         ${InternalIODir}/TcpSocketEngine_p.cpp
 )
@@ -46,6 +50,7 @@
 set ( InternalIOSources 
         ${CommonIOSources} 
         ${PlatformIOSources} 
+		${InternalPBGZFSources}
 
         PARENT_SCOPE # <-- leave this last
 )
Index: bamtools/src/api/internal/io/ParallelBgzfStream_p.cpp
===================================================================
--- bamtools/src/api/internal/io/ParallelBgzfStream_p.cpp	(revision 0)
+++ bamtools/src/api/internal/io/ParallelBgzfStream_p.cpp	(revision 43014)
@@ -0,0 +1,122 @@
+// ***************************************************************************
+// ParallelBgzfStream_p.cpp (c) 2011 Derek Barnett
+// Marth Lab, Department of Biology, Boston College
+// ---------------------------------------------------------------------------
+// Last modified: 17 January 2012(DB)
+// ---------------------------------------------------------------------------
+// Based on BGZF routines developed at the Broad Institute.
+// Provides the basic functionality for reading & writing BGZF files
+// Replaces the old BGZF.* files to avoid clashing with other toolkits
+// ***************************************************************************
+
+#include "api/BamAux.h"
+#include "api/BamConstants.h"
+#include "api/internal/io/BamDeviceFactory_p.h"
+#include "api/internal/io/BgzfStream_p.h"
+#include "api/internal/io/ParallelBgzfStream_p.h"
+#include "api/internal/utils/BamException_p.h"
+using namespace BamTools;
+using namespace BamTools::Internal;
+
+#include "zlib.h"
+
+#include <cstring>
+#include <algorithm>
+#include <iostream>
+#include <sstream>
+using namespace std;
+
+// ---------------------------
+// ParallelBgzfStream implementation
+// ---------------------------
+
+// constructor
+ParallelBgzfStream::ParallelBgzfStream(void)
+  : m_pbgzf(NULL)
+  , m_numThreads(0)
+{ }
+
+ParallelBgzfStream::ParallelBgzfStream(int32_t numThreads) 
+  : m_pbgzf(NULL)
+  , m_numThreads(numThreads)
+{ }
+
+// destructor
+ParallelBgzfStream::~ParallelBgzfStream(void) {
+    Close();
+}
+
+// closes BGZF file
+void ParallelBgzfStream::Close(void) {
+
+    // skip if no device open
+    if ( NULL == m_pbgzf) return;
+
+    // close device
+    pbgzf_close(m_pbgzf);
+    m_pbgzf = NULL;
+}
+
+bool ParallelBgzfStream::IsOpen(void) const {
+    if ( NULL == m_pbgzf )
+        return false;
+    return true;
+}
+
+void ParallelBgzfStream::Open(const string& filename, const IBamIODevice::OpenMode mode) {
+    char mode_cstr[16] = "\0";
+    // close current device if necessary
+    Close();
+    BT_ASSERT_X( (NULL == m_pbgzf), "PgzfStream::Open() - unable to properly close previous IO device" );
+
+    switch (mode) {
+        case IBamIODevice::ReadOnly:
+            strcat(mode_cstr, "r");
+            break;
+        case IBamIODevice::WriteOnly:
+            strcat(mode_cstr, "w");
+            if(m_isWriteCompressed) 
+                strcat(mode_cstr, "b");
+            break;
+        default:
+            // TODO: why would this every happen?  Don't call me this way.
+            throw BamException("PgzfStream::Open", "could not open BGZF stream");
+        break;
+    }
+            
+    pbgzf_set_num_threads_per(m_numThreads); // TODO: this needs to be set on a per "m_pbgzf" basis
+    m_pbgzf = pbgzf_open(filename.c_str(), mode_cstr); 
+    // TODO: asserts
+
+}
+
+// reads BGZF data into a byte buffer
+size_t ParallelBgzfStream::Read(char* data, const size_t dataLength) {
+
+    if ( dataLength == 0 )
+        return 0;
+
+    // TODO: asserts
+    return pbgzf_read(m_pbgzf, (void*)data, (int)dataLength);
+}
+
+// seek to position in BGZF file
+void ParallelBgzfStream::Seek(const int64_t& position) {
+
+    // TODO: asserts
+    pbgzf_seek(m_pbgzf, position, SEEK_SET);
+}
+
+// get file position in BGZF file
+int64_t ParallelBgzfStream::Tell(void) const {
+    if ( NULL == m_pbgzf )
+        return 0;
+    return pbgzf_tell(m_pbgzf);
+}
+
+// writes the supplied data into the BGZF buffer
+size_t ParallelBgzfStream::Write(const char* data, const size_t dataLength) {
+    
+    // TODO: asserts
+    return (size_t)pbgzf_write(m_pbgzf, data, dataLength);
+}
Index: bamtools/src/api/internal/io/SerialBgzfStream_p.cpp
===================================================================
--- bamtools/src/api/internal/io/SerialBgzfStream_p.cpp	(revision 0)
+++ bamtools/src/api/internal/io/SerialBgzfStream_p.cpp	(revision 43014)
@@ -0,0 +1,453 @@
+// ***************************************************************************
+// SerialBgzfStream_p.cpp (c) 2011 Derek Barnett
+// Marth Lab, Department of Biology, Boston College
+// ---------------------------------------------------------------------------
+// Last modified: 17 January 2012(DB)
+// ---------------------------------------------------------------------------
+// Based on BGZF routines developed at the Broad Institute.
+// Provides the basic functionality for reading & writing BGZF files
+// Replaces the old BGZF.* files to avoid clashing with other toolkits
+// ***************************************************************************
+
+#include "api/BamAux.h"
+#include "api/BamConstants.h"
+#include "api/internal/io/BamDeviceFactory_p.h"
+#include "api/internal/io/SerialBgzfStream_p.h"
+#include "api/internal/utils/BamException_p.h"
+using namespace BamTools;
+using namespace BamTools::Internal;
+
+#include "zlib.h"
+
+#include <cstring>
+#include <algorithm>
+#include <iostream>
+#include <sstream>
+using namespace std;
+
+// ---------------------------
+// SerialBgzfStream implementation
+// ---------------------------
+
+// constructor
+SerialBgzfStream::SerialBgzfStream(void)
+  : m_blockLength(0)
+  , m_blockOffset(0)
+  , m_blockAddress(0)
+  , m_isWriteCompressed(true)
+  , m_device(0)
+  , m_uncompressedBlock(Constants::BGZF_DEFAULT_BLOCK_SIZE)
+  , m_compressedBlock(Constants::BGZF_MAX_BLOCK_SIZE)
+{ }
+
+// destructor
+SerialBgzfStream::~SerialBgzfStream(void) {
+    Close();
+}
+
+// closes BGZF file
+void SerialBgzfStream::Close(void) {
+
+    // skip if no device open
+    if ( m_device == 0 ) return;
+
+    // if writing to file, flush the current BGZF block,
+    // then write an empty block (as EOF marker)
+    if ( m_device->IsOpen() && (m_device->Mode() == IBamIODevice::WriteOnly) ) {
+        FlushBlock();
+        const size_t blockLength = DeflateBlock(0);
+        m_device->Write(m_compressedBlock.Buffer, blockLength);
+    }
+
+    // close device
+    m_device->Close();
+    delete m_device;
+    m_device = 0;
+
+    // ensure our buffers are cleared out
+    m_uncompressedBlock.Clear();
+    m_compressedBlock.Clear();
+
+    // reset state
+    m_blockLength = 0;
+    m_blockOffset = 0;
+    m_blockAddress = 0;
+    m_isWriteCompressed = true;
+}
+
+// compresses the current block
+size_t SerialBgzfStream::DeflateBlock(int32_t blockLength) {
+
+    // initialize the gzip header
+    char* buffer = m_compressedBlock.Buffer;
+    memset(buffer, 0, 18);
+    buffer[0]  = Constants::GZIP_ID1;
+    buffer[1]  = Constants::GZIP_ID2;
+    buffer[2]  = Constants::CM_DEFLATE;
+    buffer[3]  = Constants::FLG_FEXTRA;
+    buffer[9]  = Constants::OS_UNKNOWN;
+    buffer[10] = Constants::BGZF_XLEN;
+    buffer[12] = Constants::BGZF_ID1;
+    buffer[13] = Constants::BGZF_ID2;
+    buffer[14] = Constants::BGZF_LEN;
+
+    // set compression level
+    const int compressionLevel = ( m_isWriteCompressed ? Z_DEFAULT_COMPRESSION : 0 );
+
+    // loop to retry for blocks that do not compress enough
+    int inputLength = blockLength;
+    size_t compressedLength = 0;
+    const unsigned int bufferSize = Constants::BGZF_MAX_BLOCK_SIZE;
+
+    while ( true ) {
+
+        // initialize zstream values
+        z_stream zs;
+        zs.zalloc    = NULL;
+        zs.zfree     = NULL;
+        zs.next_in   = (Bytef*)m_uncompressedBlock.Buffer;
+        zs.avail_in  = inputLength;
+        zs.next_out  = (Bytef*)&buffer[Constants::BGZF_BLOCK_HEADER_LENGTH];
+        zs.avail_out = bufferSize -
+                       Constants::BGZF_BLOCK_HEADER_LENGTH -
+                       Constants::BGZF_BLOCK_FOOTER_LENGTH;
+
+        // initialize the zlib compression algorithm
+        int status = deflateInit2(&zs,
+                                  compressionLevel,
+                                  Z_DEFLATED,
+                                  Constants::GZIP_WINDOW_BITS,
+                                  Constants::Z_DEFAULT_MEM_LEVEL,
+                                  Z_DEFAULT_STRATEGY);
+        if ( status != Z_OK )
+            throw BamException("SerialBgzfStream::DeflateBlock", "zlib deflateInit2 failed");
+
+        // compress the data
+        status = deflate(&zs, Z_FINISH);
+
+        // if not at stream end
+        if ( status != Z_STREAM_END ) {
+
+            deflateEnd(&zs);
+
+            // there was not enough space available in buffer
+            // try to reduce the input length & re-start loop
+            if ( status == Z_OK ) {
+                inputLength -= 1024;
+                if ( inputLength < 0 )
+                    throw BamException("SerialBgzfStream::DeflateBlock", "input reduction failed");
+                continue;
+            }
+
+            throw BamException("SerialBgzfStream::DeflateBlock", "zlib deflate failed");
+        }
+
+        // finalize the compression routine
+        status = deflateEnd(&zs);
+        if ( status != Z_OK )
+            throw BamException("SerialBgzfStream::DeflateBlock", "zlib deflateEnd failed");
+
+        // update compressedLength
+        compressedLength = zs.total_out +
+                           Constants::BGZF_BLOCK_HEADER_LENGTH +
+                           Constants::BGZF_BLOCK_FOOTER_LENGTH;
+        if ( compressedLength > Constants::BGZF_MAX_BLOCK_SIZE )
+            throw BamException("SerialBgzfStream::DeflateBlock", "deflate overflow");
+
+        // quit while loop
+        break;
+    }
+
+    // store the compressed length
+    BamTools::PackUnsignedShort(&buffer[16], static_cast<uint16_t>(compressedLength - 1));
+
+    // store the CRC32 checksum
+    uint32_t crc = crc32(0, NULL, 0);
+    crc = crc32(crc, (Bytef*)m_uncompressedBlock.Buffer, inputLength);
+    BamTools::PackUnsignedInt(&buffer[compressedLength - 8], crc);
+    BamTools::PackUnsignedInt(&buffer[compressedLength - 4], inputLength);
+
+    // ensure that we have less than a block of data left
+    int remaining = blockLength - inputLength;
+    if ( remaining > 0 ) {
+        if ( remaining > inputLength )
+            throw BamException("SerialBgzfStream::DeflateBlock", "after deflate, remainder too large");
+        memcpy(m_uncompressedBlock.Buffer, m_uncompressedBlock.Buffer + inputLength, remaining);
+    }
+
+    // update block data
+    m_blockOffset = remaining;
+
+    // return result
+    return compressedLength;
+}
+
+// flushes the data in the BGZF block
+void SerialBgzfStream::FlushBlock(void) {
+
+    BT_ASSERT_X( m_device, "SerialBgzfStream::FlushBlock() - attempting to flush to null device" );
+
+    // flush all of the remaining blocks
+    while ( m_blockOffset > 0 ) {
+
+        // compress the data block
+        const size_t blockLength = DeflateBlock(m_blockOffset);
+
+        // flush the data to our output device
+        const int64_t numBytesWritten = m_device->Write(m_compressedBlock.Buffer, blockLength);
+
+        // check for device error
+        if ( numBytesWritten < 0 ) {
+            const string message = string("device error: ") + m_device->GetErrorString();
+            throw BamException("SerialBgzfStream::FlushBlock", message);
+        }
+
+        // check that we wrote expected numBytes
+        if ( numBytesWritten != static_cast<int64_t>(blockLength) ) {
+            stringstream s("");
+            s << "expected to write " << blockLength
+              << " bytes during flushing, but wrote " << numBytesWritten;
+            throw BamException("SerialBgzfStream::FlushBlock", s.str());
+        }
+
+        // update block data
+        m_blockAddress += blockLength;
+    }
+}
+
+// decompresses the current block
+size_t SerialBgzfStream::InflateBlock(const size_t& blockLength) {
+
+    // setup zlib stream object
+    z_stream zs;
+    zs.zalloc    = NULL;
+    zs.zfree     = NULL;
+    zs.next_in   = (Bytef*)m_compressedBlock.Buffer + 18;
+    zs.avail_in  = blockLength - 16;
+    zs.next_out  = (Bytef*)m_uncompressedBlock.Buffer;
+    zs.avail_out = Constants::BGZF_DEFAULT_BLOCK_SIZE;
+
+    // initialize
+    int status = inflateInit2(&zs, Constants::GZIP_WINDOW_BITS);
+    if ( status != Z_OK )
+        throw BamException("SerialBgzfStream::InflateBlock", "zlib inflateInit failed");
+
+    // decompress
+    status = inflate(&zs, Z_FINISH);
+    if ( status != Z_STREAM_END ) {
+        inflateEnd(&zs);
+        throw BamException("SerialBgzfStream::InflateBlock", "zlib inflate failed");
+    }
+
+    // finalize
+    status = inflateEnd(&zs);
+    if ( status != Z_OK ) {
+        inflateEnd(&zs);
+        throw BamException("SerialBgzfStream::InflateBlock", "zlib inflateEnd failed");
+    }
+
+    // return result
+    return zs.total_out;
+}
+
+bool SerialBgzfStream::IsOpen(void) const {
+    if ( m_device == 0 )
+        return false;
+    return m_device->IsOpen();
+}
+
+void SerialBgzfStream::Open(const string& filename, const IBamIODevice::OpenMode mode) {
+
+    // close current device if necessary
+    Close();
+    BT_ASSERT_X( (m_device == 0), "SerialBgzfStream::Open() - unable to properly close previous IO device" );
+
+    // retrieve new IO device depending on filename
+    m_device = BamDeviceFactory::CreateDevice(filename);
+    BT_ASSERT_X( m_device, "SerialBgzfStream::Open() - unable to create IO device from filename" );
+
+    // if device fails to open
+    if ( !m_device->Open(mode) ) {
+        const string deviceError = m_device->GetErrorString();
+        const string message = string("could not open BGZF stream: \n\t") + deviceError;
+        throw BamException("SerialBgzfStream::Open", message);
+    }
+}
+
+// reads BGZF data into a byte buffer
+size_t SerialBgzfStream::Read(char* data, const size_t dataLength) {
+
+    if ( dataLength == 0 )
+        return 0;
+
+    // if stream not open for reading
+    BT_ASSERT_X( m_device, "SerialBgzfStream::Read() - trying to read from null device");
+    if ( !m_device->IsOpen() || (m_device->Mode() != IBamIODevice::ReadOnly) )
+        return 0;
+
+    // read blocks as needed until desired data length is retrieved
+    char* output = data;
+    size_t numBytesRead = 0;
+    while ( numBytesRead < dataLength ) {
+
+        // determine bytes available in current block
+        int bytesAvailable = m_blockLength - m_blockOffset;
+
+        // read (and decompress) next block if needed
+        if ( bytesAvailable <= 0 ) {
+            ReadBlock();
+            bytesAvailable = m_blockLength - m_blockOffset;
+            if ( bytesAvailable <= 0 )
+                break;
+        }
+
+        // copy data from uncompressed source buffer into data destination buffer
+        const size_t copyLength = min( (dataLength-numBytesRead), (size_t)bytesAvailable );
+        memcpy(output, m_uncompressedBlock.Buffer + m_blockOffset, copyLength);
+
+        // update counters
+        m_blockOffset += copyLength;
+        output        += copyLength;
+        numBytesRead  += copyLength;
+    }
+
+    // update block data
+    if ( m_blockOffset == m_blockLength ) {
+        m_blockAddress = m_device->Tell();
+        m_blockOffset  = 0;
+        m_blockLength  = 0;
+    }
+
+    // return actual number of bytes read
+    return numBytesRead;
+}
+
+// reads a BGZF block
+void SerialBgzfStream::ReadBlock(void) {
+
+    BT_ASSERT_X( m_device, "SerialBgzfStream::ReadBlock() - trying to read from null IO device");
+
+    // store block's starting address
+    const int64_t blockAddress = m_device->Tell();
+
+    // read block header from file
+    char header[Constants::BGZF_BLOCK_HEADER_LENGTH];
+    int64_t numBytesRead = m_device->Read(header, Constants::BGZF_BLOCK_HEADER_LENGTH);
+
+    // check for device error
+    if ( numBytesRead < 0 ) {
+        const string message = string("device error: ") + m_device->GetErrorString();
+        throw BamException("SerialBgzfStream::ReadBlock", message);
+    }
+
+    // if block header empty
+    if ( numBytesRead == 0 ) {
+        m_blockLength = 0;
+        return;
+    }
+
+    // if block header invalid size
+    if ( numBytesRead != static_cast<int8_t>(Constants::BGZF_BLOCK_HEADER_LENGTH) )
+        throw BamException("SerialBgzfStream::ReadBlock", "invalid block header size");
+
+    // validate block header contents
+    if ( !BgzfStream::CheckBlockHeader(header) )
+        throw BamException("SerialBgzfStream::ReadBlock", "invalid block header contents");
+
+    // copy header contents to compressed buffer
+    const size_t blockLength = BamTools::UnpackUnsignedShort(&header[16]) + 1;
+    memcpy(m_compressedBlock.Buffer, header, Constants::BGZF_BLOCK_HEADER_LENGTH);
+
+    // read remainder of block
+    const size_t remaining = blockLength - Constants::BGZF_BLOCK_HEADER_LENGTH;
+    numBytesRead = m_device->Read(&m_compressedBlock.Buffer[Constants::BGZF_BLOCK_HEADER_LENGTH], remaining);
+
+    // check for device error
+    if ( numBytesRead < 0 ) {
+        const string message = string("device error: ") + m_device->GetErrorString();
+        throw BamException("SerialBgzfStream::ReadBlock", message);
+    }
+
+    // check that we read in expected numBytes
+    if ( numBytesRead != static_cast<int64_t>(remaining) )
+        throw BamException("SerialBgzfStream::ReadBlock", "could not read data from block");
+
+    // decompress block data
+    const size_t newBlockLength = InflateBlock(blockLength);
+
+    // update block data
+    if ( m_blockLength != 0 )
+        m_blockOffset = 0;
+    m_blockAddress = blockAddress;
+    m_blockLength  = newBlockLength;
+}
+
+// seek to position in BGZF file
+void SerialBgzfStream::Seek(const int64_t& position) {
+
+    BT_ASSERT_X( m_device, "SerialBgzfStream::Seek() - trying to seek on null IO device");
+
+    // skip if device is not open
+    if ( !IsOpen() ) return;
+
+    // determine adjusted offset & address
+    int     blockOffset  = (position & 0xFFFF);
+    int64_t blockAddress = (position >> 16) & 0xFFFFFFFFFFFFLL;
+
+    // attempt seek in file
+    if ( m_device->IsRandomAccess() && m_device->Seek(blockAddress) ) {
+
+        // update block data & return success
+        m_blockLength  = 0;
+        m_blockAddress = blockAddress;
+        m_blockOffset  = blockOffset;
+    }
+    else {
+        stringstream s("");
+        s << "unable to seek to position: " << position;
+        throw BamException("SerialBgzfStream::Seek", s.str());
+    }
+}
+
+// get file position in BGZF file
+int64_t SerialBgzfStream::Tell(void) const {
+    if ( !IsOpen() )
+        return 0;
+    return ( (m_blockAddress << 16) | (m_blockOffset & 0xFFFF) );
+}
+
+// writes the supplied data into the BGZF buffer
+size_t SerialBgzfStream::Write(const char* data, const size_t dataLength) {
+
+    BT_ASSERT_X( m_device, "SerialBgzfStream::Write() - trying to write to null IO device");
+    BT_ASSERT_X( (m_device->Mode() == IBamIODevice::WriteOnly),
+                 "SerialBgzfStream::Write() - trying to write to non-writable IO device");
+
+    // skip if file not open for writing
+    if ( !IsOpen() )
+        return 0;
+
+    // write blocks as needed til all data is written
+    size_t numBytesWritten = 0;
+    const char* input = data;
+    const size_t blockLength = Constants::BGZF_DEFAULT_BLOCK_SIZE;
+    while ( numBytesWritten < dataLength ) {
+
+        // copy data contents to uncompressed output buffer
+        unsigned int copyLength = min(blockLength - m_blockOffset, dataLength - numBytesWritten);
+        char* buffer = m_uncompressedBlock.Buffer;
+        memcpy(buffer + m_blockOffset, input, copyLength);
+
+        // update counter
+        m_blockOffset   += copyLength;
+        input           += copyLength;
+        numBytesWritten += copyLength;
+
+        // flush (& compress) output buffer when full
+        if ( m_blockOffset == static_cast<int32_t>(blockLength) )
+            FlushBlock();
+    }
+
+    // return actual number of bytes written
+    return numBytesWritten;
+}
Index: bamtools/src/api/internal/io/BgzfStream_p.h
===================================================================
--- bamtools/src/api/internal/io/BgzfStream_p.h	(revision 34298)
+++ bamtools/src/api/internal/io/BgzfStream_p.h	(revision 43014)
@@ -30,61 +30,38 @@
 namespace BamTools {
 namespace Internal {
 
+// abstract class
 class BgzfStream {
 
-    // constructor & destructor
-    public:
-        BgzfStream(void);
-        ~BgzfStream(void);
-
     // main interface methods
     public:
         // closes BGZF file
-        void Close(void);
+        virtual void Close(void) = 0;
         // returns true if BgzfStream open for IO
-        bool IsOpen(void) const;
+        virtual bool IsOpen(void) const = 0;
         // opens the BGZF file
-        void Open(const std::string& filename, const IBamIODevice::OpenMode mode);
+        virtual void Open(const std::string& filename, const IBamIODevice::OpenMode mode) = 0;
         // reads BGZF data into a byte buffer
-        size_t Read(char* data, const size_t dataLength);
+        virtual size_t Read(char* data, const size_t dataLength) = 0;
         // seek to position in BGZF file
-        void Seek(const int64_t& position);
+        virtual void Seek(const int64_t& position) = 0;
         // sets IO device (closes previous, if any, but does not attempt to open)
-        void SetIODevice(IBamIODevice* device);
+        //void SetIODevice(IBamIODevice* device) = { return; };
         // enable/disable compressed output
-        void SetWriteCompressed(bool ok);
+        void SetWriteCompressed(bool ok) { m_isWriteCompressed = ok; };
         // get file position in BGZF file
-        int64_t Tell(void) const;
+        virtual int64_t Tell(void) const = 0;
         // writes the supplied data into the BGZF buffer
-        size_t Write(const char* data, const size_t dataLength);
+        virtual size_t Write(const char* data, const size_t dataLength) = 0;
 
-    // internal methods
-    private:
-        // compresses the current block
-        size_t DeflateBlock(int32_t blockLength);
-        // flushes the data in the BGZF block
-        void FlushBlock(void);
-        // de-compresses the current block
-        size_t InflateBlock(const size_t& blockLength);
-        // reads a BGZF block
-        void ReadBlock(void);
 
     // static 'utility' methods
     public:
         // checks BGZF block header
         static bool CheckBlockHeader(char* header);
 
-    // data members
-    public:
-        int32_t m_blockLength;
-        int32_t m_blockOffset;
-        int64_t m_blockAddress;
-
+    protected:
         bool m_isWriteCompressed;
-        IBamIODevice* m_device;
-
-        RaiiBuffer m_uncompressedBlock;
-        RaiiBuffer m_compressedBlock;
 };
 
 } // namespace Internal
Index: bamtools/src/api/CMakeLists.txt
===================================================================
--- bamtools/src/api/CMakeLists.txt	(revision 34298)
+++ bamtools/src/api/CMakeLists.txt	(revision 43014)
@@ -50,8 +50,8 @@
     set( APILibs z )
 endif( _WIN32 )
 
-target_link_libraries( BamTools ${APILibs} )
-target_link_libraries( BamTools-static ${APILibs} )
+target_link_libraries( BamTools ${APILibs} pthread )
+target_link_libraries( BamTools-static ${APILibs} pthread )
 
 # set library install destinations
 install( TARGETS BamTools LIBRARY DESTINATION "lib/bamtools" RUNTIME DESTINATION "bin")
Index: bamtools/src/api/BamWriter.h
===================================================================
--- bamtools/src/api/BamWriter.h	(revision 34298)
+++ bamtools/src/api/BamWriter.h	(revision 43014)
@@ -58,10 +58,13 @@
         bool SaveAlignment(const BamAlignment& alignment);
         // sets the output compression mode
         void SetCompressionMode(const BamWriter::CompressionMode& compressionMode);
+        // sets the number of threads
+        void SetNumThreads(int32_t numThreads);
 
     // private implementation
     private:
         Internal::BamWriterPrivate* d;
+        int32_t m_numThreads;
 };
 
 } // namespace BamTools
Index: bamtools/src/api/BamWriter.cpp
===================================================================
--- bamtools/src/api/BamWriter.cpp	(revision 34298)
+++ bamtools/src/api/BamWriter.cpp	(revision 43014)
@@ -37,6 +37,7 @@
 */
 BamWriter::BamWriter(void)
     : d(new BamWriterPrivate)
+    , m_numThreads(0)
 { }
 
 /*! \fn BamWriter::~BamWriter(void)
@@ -93,6 +94,7 @@
                      const std::string& samHeaderText,
                      const RefVector& referenceSequences)
 {
+    d->SetParallel(m_numThreads);
     return d->Open(filename, samHeaderText, referenceSequences);
 }
 
@@ -116,6 +118,7 @@
                      const SamHeader& samHeader,
                      const RefVector& referenceSequences)
 {
+    d->SetParallel(m_numThreads);
     return d->Open(filename, samHeader.ToString(), referenceSequences);
 }
 
@@ -150,3 +153,7 @@
 void BamWriter::SetCompressionMode(const BamWriter::CompressionMode& compressionMode) {
     d->SetWriteCompressed( compressionMode == BamWriter::Compressed );
 }
+
+void BamWriter::SetNumThreads(int32_t numThreads) {
+    m_numThreads = numThreads;
+}
diff --git a/CMakeLists.txt b/CMakeLists.txt
index b89990e..d2f9bb9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -35,8 +35,8 @@ set( BamTools_VERSION_MINOR 1 )
 set( BamTools_VERSION_BUILD 1 )
 
 # set our library and executable destination dirs
-set( EXECUTABLE_OUTPUT_PATH "${CMAKE_SOURCE_DIR}/bin" )
-set( LIBRARY_OUTPUT_PATH    "${CMAKE_SOURCE_DIR}/lib" )
+set( EXECUTABLE_OUTPUT_PATH "${CMAKE_BINARY_DIR}/bin" )
+set( LIBRARY_OUTPUT_PATH    "${CMAKE_BINARY_DIR}/lib" )
 
 # define compiler flags for all code
 set( CMAKE_BUILD_TYPE Release )
@@ -47,6 +47,7 @@ endif()
 
 # add our includes root path
 include_directories( src )
+include_directories("${CMAKE_BINARY_DIR}/include")
 
 # list subdirectories to build in
 add_subdirectory( src )
diff --git a/src/ExportHeader.cmake b/src/ExportHeader.cmake
index ec62573..ddfe410 100644
--- a/src/ExportHeader.cmake
+++ b/src/ExportHeader.cmake
@@ -18,7 +18,7 @@ function( ExportHeader MODULE FILE DEST )
     add_custom_command( TARGET ${MODULE} COMMAND
         ${CMAKE_COMMAND} -E copy_if_different
         "${CMAKE_CURRENT_SOURCE_DIR}/${FILE}"
-        "${CMAKE_SOURCE_DIR}/include/${DEST}/${FILENAME}" )
+        "${CMAKE_BINARY_DIR}/include/${DEST}/${FILENAME}" )
 
     # make sure files are properly 'installed'
     install( FILES "${FILE}" DESTINATION "include/bamtools/${DEST}" )
diff --git a/src/toolkit/CMakeLists.txt b/src/toolkit/CMakeLists.txt
index a88cf79..284566e 100644
--- a/src/toolkit/CMakeLists.txt
+++ b/src/toolkit/CMakeLists.txt
@@ -35,7 +35,7 @@ set_target_properties( bamtools_cmd PROPERTIES
                        OUTPUT_NAME "bamtools"
                      )
 # make version info available in application
-configure_file( bamtools_version.h.in ${BamTools_SOURCE_DIR}/src/toolkit/bamtools_version.h )
+configure_file( bamtools_version.h.in ${BamTools_BINARY_DIR}/include/bamtools_version.h )
 
 # define libraries to link
 target_link_libraries( bamtools_cmd BamTools BamTools-utils jsoncpp )
