#!/usr/bin/perl
# Copyright (C) 2011 Ion Torrent Systems, Inc. All Rights Reserved

#--------- Begin command arg parsing ---------

(my $CMD = $0) =~ s{^(.*/)+}{};
my $DESCR = "Create statistics for a target read coverage file (to STDOUT).
The file format is a table file with fields as generated by the targetReadCoverage.pl script.
Options include output of a depth of coverage distribution table.";
my $USAGE = "Usage:\n\t$CMD [options] <target coverage file>";
my $OPTIONS = "Options:
  -h ? --help Display Help information
  -a Indicates target regions are Amplicons rather than generic targets. Changes wording of output.
  -f Output Full statistics. This adds a few more statistics to the output, e.g. those output by previous version of TCA.
  -l Show extra log information to STDERR.
  -r RNA AmpliSeq option: Output passing (splice) coverage as statistic instead of end-to-end. Forces '-a' option.
  -D <file> Output file name for depth of coverage Distribution table (tsv) file. Default: '' (None output).
  -E <int> Threshold for end-to-end read counting based on percent end-to-end reads greaater or equal to <int>. Default: 70.
  -M <int> Number of mapped reads. If provided the percent assigned reads statistic will be output.
  -R <int> Threshold for Read coverage for strand bias to be counted. Default: 10 reads.
  -S <int> Threshold for strand Bias counting based on percent forward reads being between <int> and 100-<int>. Default: 70.";


my $docfile = '';
my $logopt = 0;
my $ampout = 0;
my $rnaopt = 0;
my $fullstats = 0;
my $mappedReads = 0;
my $thresE2E = 70;
my $thresBias = 70;
my $thresReads = 10;

my $help = (scalar(@ARGV) == 0);
while( scalar(@ARGV) > 0 )
{
  last if($ARGV[0] !~ /^-/);
  my $opt = shift;
  if($opt eq '-D') {$docfile = shift;}
  elsif($opt eq '-a') {$ampout = 1;}
  elsif($opt eq '-f') {$fullstats = 1;}
  elsif($opt eq '-l') {$logopt = 1;}
  elsif($opt eq '-r') {$rnaopt = 1;$ampout = 1;}
  elsif($opt eq '-E') {$thresE2E = int(shift);}
  elsif($opt eq '-M') {$mappedReads = int(shift);}
  elsif($opt eq '-R') {$thresReads = int(shift);}
  elsif($opt eq '-S') {$thresBias = int(shift);}
  elsif($opt eq '-h' || $opt eq "?" || $opt eq '--help') {$help = 1;}
  else
  {
    print STDERR "$CMD: Invalid option argument: $opt\n";
    print STDERR "$OPTIONS\n";
    exit 1;
  }
}
my $nargs = scalar @ARGV;
if( $help )
{
  print STDERR "$DESCR\n";
  print STDERR "$USAGE\n";
  print STDERR "$OPTIONS\n";
  exit 1;
}
elsif( $nargs != 1 )
{
  print STDERR "$CMD: Invalid number of arguments.\n";
  print STDERR "$USAGE\n";
  exit 1;
}

my $trdfile = shift(@ARGV);

# validate thresholds and turn percents to fractions
$thresBias = 0 if( $thresBias <= 0 );
$thresE2E = 0 if( $thresE2E <= 0 );
$thresBias *= 0.01;
$thresE2E  *= 0.01;

my $havedoc = ($docfile ne "" && $docfile ne "-" );

#--------- End command arg parsing ---------

die "Cannot find depth file $trdfile" unless( -e $trdfile );

# open TRDFILE and read away header string
open( TRDFILE, $trdfile ) || die "Failed to open target reads file $trdfile\n";
chomp( my $fieldIDs = <TRDFILE> );

# set defaults for anticipated required field ID indecies
my $contig_srt = 1;
my $contig_end = 2;
my $overlaps = 6;
my $fwd_e2e = 7;
my $rev_e2e = 8;
my $fwd_reads = 10;
my $rev_reads = 11;

# collect depth distribution : pre-allocate for performance
my @targetDist = ((0)x20000);
my ($targetMaxDepth,$numTargets,$numBias,$numE2E) = (0,0,0,0,0);
my $lthresBias = 1 - $thresBias;
if( $lthresBias > $thresBias )
{
  $thresBias = $lthresBias;
  $lthresBias = 1 - $thresBias;
}

# collect depth-of-reads distribution and read threshold stats
while(<TRDFILE>)
{
  chomp;
  my @fields = split("\t",$_);
  next if( $fields[0] !~ /\S/ );
  my $depth = $fields[$fwd_reads] + $fields[$rev_reads];
  my $en2en = $fields[$fwd_e2e] + $fields[$rev_e2e];
  my $rE2E  = $depth > 0 ? $en2en/$depth : 0; 
  my $rBias = $depth > 0 ? $fields[$fwd_reads]/$depth : 0.5; 
  ++$targetDist[$depth];
  $targetMaxDepth = $depth if( $depth > $targetMaxDepth );
  #$numOvlps += $fields[$overlaps];
  ++$numTargets;
  ++$numBias unless( $depth >= $thresReads && ($rBias < $lthresBias || $rBias > $thresBias) );
  ++$numE2E  unless( $rE2E < $thresE2E );
}
close(TRDFILE);

# create output stats
my $targType = $ampout ? 'Amplicon' : 'Target';
my $targetCumd = outputStats( $targType, \@targetDist, $targetMaxDepth, $numTargets );

if( $rnaopt )
{
  printf "%ss with no strand bias:       %d\n",$targType,$numBias;
  printf "%ss reading end-to-end:        %d\n",$targType,$numE2E;
}
else
{
  my $pcBias = $numTargets > 0 ? 100*$numBias/$numTargets : 0;
  printf "%ss with no strand bias:       %.2f%%\n",$targType,$pcBias;
  if( $ampout )
  {
    my $pcE2E = $numTargets > 0 ? 100*$numE2E/$numTargets : 0;
    printf "%ss reading end-to-end:        %.2f%%\n",$targType,$pcE2E;
  }
}

# output assigned read depth distribution
if( $havedoc )
{
  my $header = "read_depth\ttarget_cov\ttarget_cum_cov";
  open( DOCOUT, ">$docfile" ) || die "Cannot open file for writing $docfile.\n";  
  print DOCOUT "$header\n";
  for( my $d = 0; $d <= $targetMaxDepth; ++$d )
  {
    printf DOCOUT "%d\t%0.f\t%0.f\n", $d, $targetDist[$d], @{$targetCumd}[$d];
  }
  close( DOCOUT );
}

#-------------------------- End ------------------------

# generates output stats or given depth array and returns reference to cumulative depth array
sub outputStats
{
  my ($tag,$hist,$maxDepth,$numTargs) = @_;
  my @dist = @{$hist};
  my @cumd;
  my $tagL = lc($tag);
  my $tagU = ucfirst($tagL);
  my ($reads,$sum_reads,$sum_dreads,$cumcov) = (0,0,0,0);
  for( my $depth = $maxDepth; $depth > 0; --$depth )
  {
    $dist[$depth] += 0; # force value
    $cumcov += $dist[$depth];
    $cumd[$depth] = $cumcov; # for medians
    $reads = $depth * $dist[$depth];
    # sums for variance calculation
    $sum_reads += $reads;
    $sum_dreads += $depth * $reads;
  }
  # have to address the element directly, since dist is a copy (?)
  ${$_[1]}[0] = $numTargs - $cumcov;
  $cumd[0] = $numTargs;
  # mean read depth
  my $abc = $sum_reads / $numTargs;
  # mean and stddev for reads with at least 1x coverage ($cumcov == $cumd[1])
  my $ave = $cumcov > 0 ? $sum_reads/$cumcov : 0;
  my $std = $cumcov > 1 ? sqrt(($sum_dreads - $ave*$ave*$cumcov)/($cumcov-1)) : 0;
  my $scl = 100 / $numTargs;
  my $p2m = int(0.2*$abc+0.5);
  printf "Number of %ss:                %.0f\n",$tagL,$numTargs;
  printf "Total assigned $tagL reads:      %.0f\n",$sum_reads;
  my $sig = sigfig($abc);
  if( !$rnaopt )
  {
    if( $mappedReads > 0 )
    {
      printf "Percent assigned $tagL reads:    %.2f%%\n",100*$sum_reads/$mappedReads;
    }
    printf "Average reads per $tagL:         %.${sig}f\n",$abc;
    printf "Uniformity of $tagL coverage:    %.2f%%\n",$cumd[$p2m]*$scl;
  }
  if( $fullstats )
  {
    printf "%ss with at least 1 read:     %.0f\n",$tagU,$cumcov;
    printf "Maximum $tagL read depth:        %.0f\n",$maxDepth;
    $sig = sigfig($ave);
    printf "Average $tagL read depth:            %.${sig}f\n",$ave;
    $sig = sigfig($std);
    printf "Std.Dev $tagL read depth:            %.${sig}f\n",$std;
  }
  if( $rnaopt )
  {
    printf "%ss with at least 1 read:     %d\n",$tagU,$cumd[1];
    printf "%ss with at least 10 reads:   %d\n",$tagU,$cumd[10];
    printf "%ss with at least 100 reads:  %d\n",$tagU,$cumd[100];
    printf "%ss with at least 1000 reads: %d\n",$tagU,$cumd[1000];
    printf "%ss with at least 10K reads:  %d\n",$tagU,$cumd[10000];
    printf "%ss with at least 100K reads: %d\n",$tagU,$cumd[100000];
  }
  else
  {
    printf "%ss with at least 1 read:     %.2f%%\n",$tagU,$cumd[1]*$scl;
    printf "%ss with at least 10 reads:   %.2f%%\n",$tagU,$cumd[10]*$scl if( $fullstats );
    printf "%ss with at least 20 reads:   %.2f%%\n",$tagU,$cumd[20]*$scl;
    printf "%ss with at least 50 reads:   %.2f%%\n",$tagU,$cumd[50]*$scl if( $fullstats );
    printf "%ss with at least 100 reads:  %.2f%%\n",$tagU,$cumd[100]*$scl;
    printf "%ss with at least 500 reads:  %.2f%%\n",$tagU,$cumd[500]*$scl;
  }
  return \@cumd;
}

sub sigfig
{
  my $val = $_[0];
  return 0 if( $val ) >= 1000;
  return 1 if( $val ) >= 100;
  return 2 if( $val ) >= 10;
  return 3;
}

