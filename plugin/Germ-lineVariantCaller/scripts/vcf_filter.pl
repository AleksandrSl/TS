#!/usr/bin/env perl
# Copyright (C) 2010 Ion Torrent Systems, Inc. All Rights Reserved

# Author: lh3
# Modified by Nils Homer <nils.homer@lifetech.com>

use strict;
use warnings;
use Getopt::Std;

&varFilter;
exit;

sub varFilter {
  my %opts = (d=>2, D=>10000000, a=>2, W=>10, Q=>10, w=>10, p=>undef, 1=>1e-4, 2=>1e-100, 3=>0, 4=>1e-4, s=>1, S=>1, H=>2);
  getopts('pd:D:W:Q:w:a:1:2:3:4:s:S:H:', \%opts);
  die(qq/
Usage:   vcf_filter.pl [options] <in.vcf>

Options: -Q INT    minimum RMS mapping quality for SNPs [$opts{Q}]
         -d INT    minimum read depth [$opts{d}]
         -D INT    maximum read depth [$opts{D}]
         -a INT    minimum number of alternate bases [$opts{a}]
         -w INT    SNP within INT bp around a gap to be filtered [$opts{w}]
         -W INT    window size for filtering adjacent gaps [$opts{W}]
         -1 FLOAT  min P-value for strand bias (given PV4) [$opts{1}]
         -2 FLOAT  min P-value for baseQ bias [$opts{2}]
         -3 FLOAT  min P-value for mapQ bias [$opts{3}]
         -4 FLOAT  min P-value for end distance bias [$opts{4}]
         -s INT    minimum read depth for SNPs on each strand [$opts{s}]
         -S INT    minimum read depth for INDELs on each strand [$opts{S}]
		 -H INT    minimum read depth for Homopolymer INDELs on each strand [$opts{H}]
         -p        print filtered variants

Note: Some of the filters rely on annotations generated by SAMtools\/BCFtools.
\n/) if (@ARGV == 0 && -t STDIN);

  # calculate the window size
  my ($ol, $ow) = ($opts{W}, $opts{w});
  my $max_dist = $ol > $ow? $ol : $ow;
  # the core loop
  my @staging; # (indel_filtering_score, flt_tag, indel_span; chr, pos, ...)
  while (<>) {
	my @t = split;
    if (/^#/) {
	  print; next;
	}
	next if ($t[4] eq '.'); # skip non-var sites
    next if ($t[3] eq 'N'); # skip sites with unknown ref ('N')
	# check if the site is a SNP
	my $type = 1; # SNP
	if (length($t[3]) > 1) {
	  $type = 2; # MNP
	  my @s = split(',', $t[4]);
	  for (@s) {
		$type = 3 if (length != length($t[3]));
	  }
	} else {
	  my @s = split(',', $t[4]);
	  for (@s) {
		$type = 3 if (length > 1);
	  }
	}
	# clear the out-of-range elements
	while (@staging) {
      # Still on the same chromosome and the first element's window still affects this position?
	  last if ($staging[0][3] eq $t[0] && $staging[0][4] + $staging[0][2] + $max_dist >= $t[1]);
	  varFilter_aux(shift(@staging), $opts{p}); # calling a function is a bit slower, not much
	}
	my $flt = "";
	# parse annotations
	my ($dp, $mq, $dp_alt) = (-1, -1, -1);
	if ($t[7] =~ /DP4=(\d+),(\d+),(\d+),(\d+)/i) {
	  $dp = $1 + $2 + $3 + $4;
	  $dp_alt = $3 + $4;
	  if ($type == 3) { # an indel
		  my $indel_type = 0;
		  my @s = split(',', $t[4]);
		  foreach my $indel (@s) {
			  my $left = "";
			  if(1 == is_indel_an_hp($t[3], $indel)) {
				  $indel_type = 1;
				  last;
			  }
		  }
		  if ($3 < $opts{S} || $4 < $opts{S}) {
			  $flt .= "S";
		  }
		  if (1 == $indel_type) {
			  if ($3 < $opts{H} || $4 < $opts{H}) {
				  $flt .= "H";
			  }
		  }
	  }
	  else { # SNP
		  if ($3 < $opts{s} || $4 < $opts{s}) {
			  $flt .= "s";
		  }
	  }
	}
	if ($t[7] =~ /DP=(\d+)/i) {
	  $dp = $1;
	}
	$mq = $1 if ($t[7] =~ /MQ=(\d+)/i);
	# the depth and mapQ filter
	if ($dp >= 0) {
	  if ($dp < $opts{d}) {
		$flt .= "d";
	  } elsif ($dp > $opts{D}) {
		$flt .= "D";
	  }
	}
	$flt .= "a" if ($dp_alt >= 0 && $dp_alt < $opts{a});
	$flt .= "Q" if ($mq >= 0 && $mq < $opts{Q});
	if (/PV4=([^,]+),([^,]+),([^,]+),([^,;\t]+)/) {
		if ($1<$opts{1}) {
			$flt .= "1";
		}
		elsif ($2<$opts{2}) {
			$flt .= "2";
		}
		elsif ($3<$opts{3}) {
			$flt .= "3";
		}
		elsif ($4<$opts{4}) {
			$flt .= "4";
		}
	}

	my $score = $t[5] * 100 + $dp_alt;
	my $rlen = length($t[3]) - 1; # $indel_score<0 for SNPs
	if ($type == 3) { # an indel
		# filtering SNPs and MNPs
		for my $x (@staging) {
			next if (($x->[0]&3) == 3 || "" ne $x->[1] || $x->[4] + $x->[2] + $ow < $t[1]);
			$x->[1] .= "w";
		}
		# check the staging list for indel filtering
		for my $x (@staging) {
			next if (($x->[0]&3) != 3 || "" ne $x->[1] || $x->[4] + $x->[2] + $ol < $t[1]);
			if ($x->[0]>>2 < $score) {
				$x->[1] .= "W";
			} else {
				$flt .= "W"; last;
			}
		}
	} else { # SNP or MNP
		for my $x (@staging) {
			next if (($x->[0]&3) != 3 || $x->[4] + $x->[2] + $ow < $t[1]);
			if ($x->[4] + length($x->[7]) - 1 == $t[1] && substr($x->[7], -1, 1) eq substr($t[4], 0, 1)
				&& length($x->[7]) - length($x->[6]) == 1) {
				$x->[1] .= "w";
			} else { $flt .= "w"; }
			last;
		}
		# check MNP
		for my $x (@staging) {
			next if (($x->[0]&3) == 3 || $x->[4] + $x->[2] < $t[1]);
			if ($x->[0]>>2 < $score) {
				$x->[1] .= "2";
			} else {
				$flt .= "2"; last;
			}
		}
	}
	push(@staging, [$score<<2|$type, $flt, $rlen, @t]);
  }
  # output the last few elements in the staging list
  while (@staging) {
	varFilter_aux(shift @staging, $opts{p});
  }
}

sub varFilter_aux {
  my ($first, $is_print) = @_;
  if ($first->[1] eq "") {
	print join("\t", @$first[3 .. @$first-1]), "\n";
  } elsif ($is_print) {
	print STDERR join("\t", $first->[1], @$first[3 .. @$first-1]), "\n";
  }
}

sub is_indel_an_hp {
    my ($a, $b) = @_;
    my $index;

	# Makes sure that length(a) <= length(b)
    if (length($a) > length($b)) {
        return is_indel_an_hp($b, $a);
    }      

    # Step 1: find the largest common prefix
    for ($index = 0; $index < length($a); $index++) {
        if(substr($a, $index, 1) ne substr($b, $index, 1)) {
            last;
        }
    }

    # Step 2: see if the gap is an hp
    if (substr($b, $index, length($b) - length($a)) =~ m/^(A+|C+|G+|T+)$/) {
        return 1;
    }
    return 0;
}
