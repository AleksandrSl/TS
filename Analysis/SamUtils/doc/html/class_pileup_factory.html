<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SamUtils: PileupFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="300px-Lightning_storm_over_Boston_-_NOAA.jpg"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">SamUtils</div>
   <div id="projectbrief">Utility classes for working with SAM/BAM files.  Also provides some basic quality utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_pileup_factory.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">PileupFactory Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="PileupFactory" -->
<p><code>#include &lt;<a class="el" href="_pileup_8h_source.html">Pileup.h</a>&gt;</code></p>

<p><a href="class_pileup_factory-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory_1_1pileup__iterator.html">pileup_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
std::tr1::unordered_map&lt; int, <br class="typebreak"/>
<a class="el" href="class_pileup.html">Pileup</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#ae4c0b96c035216ba005467e2d5fc3397">pileup_container_t</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a0f382d75621a4b7d6cc5fd0c1d749e5e">PileupFactory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#ae8550e54b25cea368a5cc8ba618a80e5">PileupFactory</a> (int tid, int start_pos, int end_pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#acbc56060b1f13b7d1cdb4acba5b6c451">PileupFactory</a> (int tid, int start_pos, int end_pos, vector&lt; int &gt; &amp;phreds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a2b95a68ddb7f2bcd6d828e6733cca118">PileupFactory</a> (int tid, int start_pos, int end_pos, vector&lt; int &gt; &amp;phreds, std::vector&lt; <a class="el" href="class_b_a_m_read.html">BAMRead</a> &gt; &amp;the_overlaps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a34aafd5bef78d8b1cf6ed40cc7d07e70">PileupFactory</a> (<a class="el" href="class_pileup_factory.html">PileupFactory</a> const &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pileup_factory.html">PileupFactory</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a152705c18ce0fb952bf89c0783752bca">operator=</a> (<a class="el" href="class_pileup_factory.html">PileupFactory</a> that)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a227de38502522bf50b855d1a8b7f5a6f">init_factory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a1920bc4147b24073bf616ffb29f7ab5c">insert_util</a> (<a class="el" href="class_b_a_m_utils.html">BAMUtils</a> &amp;util)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pileup.html">Pileup</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#ad61e4f1bfe0ce99004d5e07e0697d0de">get_pileup</a> (int pos_in_genome)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#aa0f1f6e20f54688154b710a63b41d457">is_pos_covered</a> (int pos_in_genome, int phred_score)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pileup_factory_1_1pileup__iterator.html">pileup_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#ab41f2591c7092b2800ba8768a3b593a6">get_pileup_iterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a4d203d432afda6c43c207f4b5e4062de">set_overlap_reads</a> (std::vector&lt; <a class="el" href="class_b_a_m_read.html">BAMRead</a> &gt; &amp;the_overlaps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#abfb03a6dad3dbc9d7216c2d96174b42f">handle_overlaps</a> (std::string &amp;q_score_str, coord_t start_slop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a735687db4dba9bbd23d4ecca73b9fc1a">release_resources</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#a7fa771e82cda5f6c17bc3c488bac9ad6">get_start</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pileup_factory.html#af7f9b6c0c1d5c5d3615bbf7fb1024731">get_end</a> () const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This class attempts to encapsulate a Genomic window. Given a start position, and a stop position inside 1 reference sequence <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> objects can be inserted. Upon insertion of reads, assuming they're in the window, the Factory becomes query-able.</p>
<p>Best practices for use of this factory are to insert all <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> from the window BEFORE trying to use other member functions.</p>
<p>This object can be very memory intensive, and is compute intensive. It is advised that you keep the windows small if you suspect the possibility of extreme levels of coverage (in excess of 100x). The advised window length is 10 kilobases.</p>
<p>The start and stop positions of the window are inclusive.</p>
<p>The start and stop positions are 1-based. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ae4c0b96c035216ba005467e2d5fc3397"></a><!-- doxytag: member="PileupFactory::pileup_container_t" ref="ae4c0b96c035216ba005467e2d5fc3397" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tr1::unordered_map&lt;int, <a class="el" href="class_pileup.html">Pileup</a>&gt; <a class="el" href="class_pileup_factory.html#ae4c0b96c035216ba005467e2d5fc3397">PileupFactory::pileup_container_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>an STL container that implements some key,value </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f382d75621a4b7d6cc5fd0c1d749e5e"></a><!-- doxytag: member="PileupFactory::PileupFactory" ref="a0f382d75621a4b7d6cc5fd0c1d749e5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PileupFactory::PileupFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Default constructor. A necessary evil in order to use these objects in STL containers </p>

</div>
</div>
<a class="anchor" id="ae8550e54b25cea368a5cc8ba618a80e5"></a><!-- doxytag: member="PileupFactory::PileupFactory" ref="ae8550e54b25cea368a5cc8ba618a80e5" args="(int tid, int start_pos, int end_pos)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PileupFactory::PileupFactory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Standard constructor. This constructor will setup a default list of phred scores to observe coverage at: 7,10,17,20,47</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>tid index of reference from SAM/BAM header </td></tr>
    <tr><td class="paramname">int</td><td>start_pos start position of window </td></tr>
    <tr><td class="paramname">int</td><td>end_pos end position of window </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup_factory.html">PileupFactory</a> a constructed <a class="el" href="class_pileup_factory.html">PileupFactory</a> that's ready for <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="acbc56060b1f13b7d1cdb4acba5b6c451"></a><!-- doxytag: member="PileupFactory::PileupFactory" ref="acbc56060b1f13b7d1cdb4acba5b6c451" args="(int tid, int start_pos, int end_pos, vector&lt; int &gt; &amp;phreds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PileupFactory::PileupFactory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>phreds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If using custom phred scores, you require this constructor.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>tid index of reference from SAM/BAM header </td></tr>
    <tr><td class="paramname">int</td><td>start_pos start position of window </td></tr>
    <tr><td class="paramname">int</td><td>end_pos end position of window </td></tr>
    <tr><td class="paramname">vector&lt;int&gt;</td><td>phreds list of phred scores to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup_factory.html">PileupFactory</a> a constructed <a class="el" href="class_pileup_factory.html">PileupFactory</a> that's ready for <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a2b95a68ddb7f2bcd6d828e6733cca118"></a><!-- doxytag: member="PileupFactory::PileupFactory" ref="a2b95a68ddb7f2bcd6d828e6733cca118" args="(int tid, int start_pos, int end_pos, vector&lt; int &gt; &amp;phreds, std::vector&lt; BAMRead &gt; &amp;the_overlaps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PileupFactory::PileupFactory </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>phreds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_b_a_m_read.html">BAMRead</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_overlaps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>I initially designed this constructor to be used in the case of a region that overlaps a previous genomic window. The reads that overlapped would be passed in at construction to make I/O code in <a class="el" href="class_align_stats.html">AlignStats</a> much simpler.</p>
<p>However, if you already have a list of reads that are within the window for this new Factory you can simply pass them in the constructor here, and the returned <a class="el" href="class_pileup_factory.html">PileupFactory</a> will be immediately ready to use.</p>
<p>If the input <a class="el" href="class_b_a_m_read.html">BAMRead</a> vector is large, this constructor can take a large amount of time to execute. <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> objects are created for each <a class="el" href="class_b_a_m_read.html">BAMRead</a>, and then inserted into an internal data structure containing a <a class="el" href="class_pileup.html">Pileup</a> for each position in the window.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>tid index of reference from SAM/BAM header </td></tr>
    <tr><td class="paramname">int</td><td>start_pos start position of window </td></tr>
    <tr><td class="paramname">int</td><td>end_pos end position of window </td></tr>
    <tr><td class="paramname">vector&lt;int&gt;</td><td>phreds list of phred scores to use </td></tr>
    <tr><td class="paramname">vector&lt;BAMRead&gt;</td><td>the_overlaps A vector of BAMRead(s) ready to be inserted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup_factory.html">PileupFactory</a> a constructed <a class="el" href="class_pileup_factory.html">PileupFactory</a> that's ready for <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> objects </dd></dl>

</div>
</div>
<a class="anchor" id="a34aafd5bef78d8b1cf6ed40cc7d07e70"></a><!-- doxytag: member="PileupFactory::PileupFactory" ref="a34aafd5bef78d8b1cf6ed40cc7d07e70" args="(PileupFactory const &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PileupFactory::PileupFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pileup_factory.html">PileupFactory</a> const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy constructor</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="class_pileup_factory.html">PileupFactory</a></td><td>const&amp; other Factory to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup_factory.html">PileupFactory</a> a copy of other </dd></dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af7f9b6c0c1d5c5d3615bbf7fb1024731"></a><!-- doxytag: member="PileupFactory::get_end" ref="af7f9b6c0c1d5c5d3615bbf7fb1024731" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PileupFactory::get_end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns end of genomic window defined in construction</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int end position of genomic window </dd></dl>

</div>
</div>
<a class="anchor" id="ad61e4f1bfe0ce99004d5e07e0697d0de"></a><!-- doxytag: member="PileupFactory::get_pileup" ref="ad61e4f1bfe0ce99004d5e07e0697d0de" args="(int pos_in_genome)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pileup.html">Pileup</a> PileupFactory::get_pileup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos_in_genome</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a <a class="el" href="class_pileup.html">Pileup</a> given a position in the genome. If position is outside of the genomic window a default constructed <a class="el" href="class_pileup.html">Pileup</a> is returned.</p>
<p>If the position has no coverage, a default constructed <a class="el" href="class_pileup.html">Pileup</a> object is returned</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>pos_in_genome 1-based position in genome </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup.html">Pileup</a> a <a class="el" href="class_pileup.html">Pileup</a> object for pos_in_genome </dd></dl>

</div>
</div>
<a class="anchor" id="ab41f2591c7092b2800ba8768a3b593a6"></a><!-- doxytag: member="PileupFactory::get_pileup_iterator" ref="ab41f2591c7092b2800ba8768a3b593a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pileup_factory_1_1pileup__iterator.html">pileup_iterator</a> PileupFactory::get_pileup_iterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns an iterator for the Pileups inside the factory.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="class_pileup_factory_1_1pileup__iterator.html">PileupFactory::pileup_iterator</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7fa771e82cda5f6c17bc3c488bac9ad6"></a><!-- doxytag: member="PileupFactory::get_start" ref="a7fa771e82cda5f6c17bc3c488bac9ad6" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PileupFactory::get_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns start of genomic window defined in construction </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>int start position of genomic window </dd></dl>

</div>
</div>
<a class="anchor" id="abfb03a6dad3dbc9d7216c2d96174b42f"></a><!-- doxytag: member="PileupFactory::handle_overlaps" ref="abfb03a6dad3dbc9d7216c2d96174b42f" args="(std::string &amp;q_score_str, coord_t start_slop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PileupFactory::handle_overlaps </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>q_score_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">coord_t&#160;</td>
          <td class="paramname"><em>start_slop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used ONLY AFTER you have just called:</p>
<p><a class="el" href="class_pileup_factory.html#a4d203d432afda6c43c207f4b5e4062de">PileupFactory::set_overlap_reads(std::vector&lt;BAMRead&gt;&amp; the_overlaps)</a></p>
<p>This is computationally expensive depending on the genomic window size. It automatically inserts all the reads passed in <a class="el" href="class_pileup_factory.html#a4d203d432afda6c43c207f4b5e4062de">PileupFactory::set_overlap_reads(std::vector&lt;BAMRead&gt;&amp; the_overlaps)</a> into the internal data structure, and resulting <a class="el" href="class_pileup.html">Pileup</a> objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>q_score_str a string representation of the phred scores </td></tr>
    <tr><td class="paramname">coord_t</td><td>start_slop number of bases at the start of the read to ignore for error calculations) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a227de38502522bf50b855d1a8b7f5a6f"></a><!-- doxytag: member="PileupFactory::init_factory" ref="a227de38502522bf50b855d1a8b7f5a6f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PileupFactory::init_factory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If performance is on your mind, this sets up the internal data structure </p>

</div>
</div>
<a class="anchor" id="a1920bc4147b24073bf616ffb29f7ab5c"></a><!-- doxytag: member="PileupFactory::insert_util" ref="a1920bc4147b24073bf616ffb29f7ab5c" args="(BAMUtils &amp;util)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PileupFactory::insert_util </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_b_a_m_utils.html">BAMUtils</a> &amp;&#160;</td>
          <td class="paramname"><em>util</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Inserts a <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> object into some Pileup(s). The function determines which Pileup(s) are effected, finds them, and adds this <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> to it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">BAMUtils&amp;</td><td>util a reference to an existing <a class="el" href="class_b_a_m_utils.html">BAMUtils</a> object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0f1f6e20f54688154b710a63b41d457"></a><!-- doxytag: member="PileupFactory::is_pos_covered" ref="aa0f1f6e20f54688154b710a63b41d457" args="(int pos_in_genome, int phred_score)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PileupFactory::is_pos_covered </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos_in_genome</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phred_score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience method so you can avoid handling <a class="el" href="class_pileup.html">Pileup</a> objects all together if you want. Returns true if the position is covered by phred_score reads.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>pos_in_genome 1-based position in genome to inspect </td></tr>
    <tr><td class="paramname">int</td><td>phred_score Phred score you're interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>bool true if position is covered by reads in the factory </dd></dl>

</div>
</div>
<a class="anchor" id="a152705c18ce0fb952bf89c0783752bca"></a><!-- doxytag: member="PileupFactory::operator=" ref="a152705c18ce0fb952bf89c0783752bca" args="(PileupFactory that)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pileup_factory.html">PileupFactory</a>&amp; PileupFactory::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pileup_factory.html">PileupFactory</a>&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Overloaded operator= that calls the copy constructor </p>

</div>
</div>
<a class="anchor" id="a735687db4dba9bbd23d4ecca73b9fc1a"></a><!-- doxytag: member="PileupFactory::release_resources" ref="a735687db4dba9bbd23d4ecca73b9fc1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PileupFactory::release_resources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears internal resources </p>

</div>
</div>
<a class="anchor" id="a4d203d432afda6c43c207f4b5e4062de"></a><!-- doxytag: member="PileupFactory::set_overlap_reads" ref="a4d203d432afda6c43c207f4b5e4062de" args="(std::vector&lt; BAMRead &gt; &amp;the_overlaps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PileupFactory::set_overlap_reads </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_b_a_m_read.html">BAMRead</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>the_overlaps</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allows you to input a vector of BAMRead's. Warning: do not do this if you supplied this vector during construction. It will overwrite an internal class member.</p>
<p>If this function is used, you need to call:</p>
<p><a class="el" href="class_pileup_factory.html#abfb03a6dad3dbc9d7216c2d96174b42f">PileupFactory::handle_overlaps(std::string&amp; q_score_str, coord_t start_slop)</a>;</p>
<p>The reason that handle_overlaps isn't called is because it can be computationally expensive, and this allows the user of the class to copy the data into the Factory, but not necessarily do the heavy computation aspect of it right away.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;BAMRead&gt;&amp;</td><td>the_overlaps reads that mapped to this genomic region </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>types/<a class="el" href="_pileup_8h_source.html">Pileup.h</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_pileup_factory.html">PileupFactory</a>      </li>
      <li class="footer">Generated on Tue Jun 28 2011 16:13:41 for SamUtils by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
