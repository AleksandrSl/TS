User Interface Internals
========================

The Torrent PC Analysis Suite user interface mixes server-side
`Django <http://djangoproject.com/>`_
templating with client side JavaScript, powered by `jQuery
<http://jquery.com/>`_. The entire interface is styled with CSS found in
``media/stylesheet.css``. Furthermore, some styling is applied directly with
JavaScript. As one might guess, these components do not always interact in
the most transparent ways.

The UI's tooltips provide a good example. Here is the entire process required
to pop up a tooltip window when the user hovers over a tooltip-enabled piece
of text. Let's consider the "search by experiment" tooltip found on the
`experiments <https://analysis.iontorrents.com/rundb/>`_ page.

#. When the web server starts, it imports the ``iondb.rundb.tooltips`` module,
   which in turn loads the file ``iondb/rundb/tooltips.txt``, and parses
   the tooltip descriptions it contains. One of these descriptions is titled
   "Search By Experiment" and has the key "exp_searchbyexp."
#. When a user requests the experiments page, Django renders a template,
   specifically ``iondb/templates/rundb/ion_experiment_new.html``. This
   template contains a custom `Django tag
   <http://docs.djangoproject.com/en/dev/howto/custom-template-tags/>`_
   called ``tooltip``, which is loaded with ``{% load embeddedhelp %}``.
   The tag ``{% tooltip exp_searchbyexp %}`` generates a snippet of
   html::
   
     <span class="tooltip">/rundb/tooltip/exp_searchbyexp</span>

#. The CSS class "tooltip" makes this ``span`` invisible (``display:none``).
#. When the browser has finished loading the page, it fires a series of
   `jQuery callbacks <http://api.jquery.com/jQuery/#jQuery3>`_ that
   add additional styling to the page and attach event handlers to certain
   nodes in the `DOM <http://en.wikipedia.org/wiki/Document_Object_Model>`_.
   One of these callbacks handles tooltips. It finds all `DOM nodes with
   class "tooltip" <http://api.jquery.com/jQuery/#jQuery1>`_
   (``$(".tooltip")``).
   It then looks at their direct parents in the DOM tree
   (``$(".tooltip").parent())``), and applies the CSS class "tooltip_parent" to
   these nodes. As a result, the text "Search by Experiment" is underlined with
   a fine dotted black line.
#. Another jQuery callback attaches a ``hover`` event to the tooltip parent
   nodes. The hover event, when triggered, calls the function
   ``retrieveTooltip``.
#. When the user hovers (mouses over) the underlined "Search by Experiment"
   text, the ``retrieveTooltip`` function is called. It first applies the
   "tooltip_highlighted" CSS class to the "Search by Experiment" text. Then
   it fires off an AJAX request to "/rundb/tooltip/exp_searchbyexp", the
   text contained in the "exp_searchbyexp" tooltip span.
#. The web server receives this request, which is processed by the view
   ``iondb.rundb.ajax.tooltip``. The last part of the URL, "exp_searchbyexp"
   tells the ``tooltip`` view the key of the tooltip to return. The ``tooltip``
   view then looks for "exp_searchbyexp" by calling
   ``iondb.rundb.tooltips.tip``. The function returns a Python object which
   can be serialized to `JSON <http://json.org>`_. Usually, this will
   be a dictionary containing a "title" field and a "text" field. The
   ``tooltip`` view serializes this dictionary to a UTF-8 encoded JSON string
   and returns it as a response to the original AJAX request.
#. Upon receiving the response, the browser calls a JavaScript closure
   generated by the function ``tooltipCbFactory``. This closure creates
   a `jQuery UI dialog box <http://jqueryui.com/demos/dialog/>`_. The
   closure then sets the dialog's title and content according to the
   "title" and "text" fields it received in the AJAX response. Finally,
   it displays the dialog to the user slightly below the "Search By Experiment"
   text.

jQuery Callbacks
----------------

These JavaScript functions are called by ``$(document).ready()``. They appear
in ``iondb/media/scripts.js``. These functions follow the naming convention
``prep_*``.

.. function:: prep_graphable()

   Generates an ionogram from a test fragment template. For each element
   with class ``graphable``, the function looks for this pattern in the DOM: ::

     <tr class="row1 graphable" id="1_row">...</tr>
     <tr id="1">
       <td class="sequence">TGTGA...</td>
       ...
       <div  id="1_graph" class="graph_holder"></div>
     </tr>
   
   Notice how the first ``tr`` has ID "1_row" and the next table row has
   ID "1". The first row ID must start with "<row number>_" in order to 
   be matched with the sequence in the net row.
   
   ``prep_graphable`` calls :func:`graph_template` to generate an ionogram,
   with the ``sequence`` argument extracted from the node with class
   "sequence".
   :func:`graph_template` then inserts the ionogram image into the node with
   ID "<row number>_graph".

.. function:: prep_tooltip()

   First, adds the class "tooltip_parent" to the parent nodes of everything
   matched
   by ``$(".tooltip")``. This adds the dotted underline to all tooltip text.
   
   Next, ``prep_tooltip`` binds the ``retrieveTooltip`` function to the
   "hover" event. When the event is triggered, ``retrieveTooltip`` begins
   the process of getting the tooltip from the web server.

.. function:: prep_tooltip_summary()

   Binds the function ``gatherTooltips`` on click to DOM nodes with class
   "tooltip_summary". When the event is triggered, ``gatherTooltips`` retrieves
   all tooltips on the page from the web server and displays them in a single
   large `modal <http://jqueryui.com/demos/dialog/#option-modal>`_ dialog box.

.. function:: prep_controlform()

   Binds the function ``submitControlForm`` on change to all ``input`` and
   ``select`` elements within a DOM subtree of the form::

     <form id="#control_form" ... >
       <table><tbody><tr><td>
         ...
       </td></tr></tbody></table>
     </form>

   Whenever an ``input`` or ``select`` is modified, the control form is
   submitted, and the list of database objects (either ``models.Experiment``
   or ``models.Results`` objects) is updated.

.. function:: prep_tabs()

   Binds a hover event to all DOM nodes with class "tabtext". When triggered,
   the event changes the node's background color from gray ("#cccccc") to
   white ("#ffffff"). The currently selected tab does not change color.

.. function:: prep_tab_corners()

   Applies two jQuery UI styles to DOM nodes with class "tabtext":
   `ui-corner-tl <http://jqueryui.com/docs/Theming/API#Corner_Radius_helpers>`_
   and `ui-corner-tr
   <http://jqueryui.com/docs/Theming/API#Corner_Radius_helpers>`_.

.. function:: prep_star()
   
   Binds the function ``star`` on click to ``input`` elements within DOM nodes
   of class "star_td". The ``start`` function sends an AJAX request to the
   web server, instructing Django to set or unset the ``star`` field of
   a ``models.Experiment`` object.

.. function:: prep_icon_toggling()
   
   Binds a click event to all DOM nodes of the form::

     <span class="icon_link">
       <span class="__icon_1">class_name_1</span>
       <span class="__icon_2">class_name_2</span>
     </span>

   Although the node types must not necessarily be ``span``. When the click
   event is triggered, the node with class "icon_link" removes
   the class contained in the text of the "__icon_1" node and adds that from the
   text of the "__icon_2" node.

   For example::
   
     <!-- before click -->
     <span class="icon_link class_name_1">
       <span class="__icon_1">class_name_1</span>
       <span class="__icon_2">class_name_2</span>
     </span>

     <!-- after click -->
     <span class="icon_link class_name_2">
       <span class="__icon_1">class_name_1</span>
       <span class="__icon_2">class_name_2</span>
     </span>

.. function:: prep_icon_effects()

   Adds highlighting on mouseover to DOM nodes with class "icon_link".

.. function:: prep_sorting_text()

   Bind a click event to DOM nodes matching
   ``$(".sortables > th > .sortheading")``. When triggered the event calls
   ``setSorting`` with the node's parent element as the argument. This allows
   for toggling ascending/descending sorting based on the clicked node (see
   `sorting` for more details).

.. function:: prep_sorting_buttons()

   Add up-arrow and down-arrow buttons for sorting to sortable elements
   (roughly, those nodes that are matched by
   ``$(".sortables > th > .sortheading")``.

.. function:: prep_centering_ie6()
   
   Add the class "centered_ie6" to nodes with class "centered" if the 
   browser does not support "box model" rendering.

.. function:: prep_centering_width()
   
   Bind an on resize event to the browser window. When the window is resized,
   the ``div`` node with class "all", which wraps the entire UI, is resized
   as well. This seems to be a nice cross-browser solution to maintaining a
   fixed-width margin on both the left and right sides of the screen.

JavaScript Functions
--------------------

.. data:: MOUSEOVER_DELAY

   Number of milliseconds between the time the user hovers over a tooltip
   and the appearance of a tooltip dialog box. Currently set to 750.

Visibility Controls
^^^^^^^^^^^^^^^^^^^

Functions for showing/hiding DOM nodes.

.. function:: toggleTr(id)

   Perform the jQuery `toggle effect <http://api.jquery.com/toggle/>`_
   on the element with ID ``id + "_holder"``::

      <a href="javascript:toggleTr('123')">
      	 Click me to reveal the hidden DIV below.
      </a>
      <div id="123_holder">Click the link above to reveal me.</div>

.. function:: toggleAdvanced(id)

   Toggle (see :func:`toggleTr`) the node with ID ``id``.

.. function:: clickExpand(id)

   Programmatically click all anchors with class "icon_link" beneath the
   node with ID ``id``

Starring
^^^^^^^^

.. function:: star()

   Dispatch an AJAX request to "star" a ``models.Experiment`` database
   record::

      <input type="checkbox" id="star_123" onchange="star()"/>
    
   Clicking this checkbox will "star" the star the ``models.Experiment`` record
   with primary key 123.

Job Control and Termination
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Functions for terminating jobs. These methods are used in the "Jobs" page,
which is rendered by :func:`rundb.views.current_jobs`.

.. function:: do_control(url)

   Make an AJAX request using jQuery's `getJSON 
   <http://api.jquery.com/jQuery.getJSON/>`_ to ``url``. Registers a callback
   with `getJSON` that displays the result of the AJAX call (either 
   "termination succeded" or "termination failed") to the user.

.. function:: build_control_dialogue(url,name)

   Display a jQuery `dialog box <http://jqueryui.com/demos/dialog>` which
   presents the user with the option to terminate a job. If the user
   clicks "Terminate", the function calls :func:`do_control` with argument
   ``url``.

TF Ionogram Creation
^^^^^^^^^^^^^^^^^^^^

.. function:: graph_template(sequence,graph_node)

   Convert nucleotide sequence ``sequence`` into flowspaces using floworder
   "TACG", then create an ionogram using `jQuery Google Charts API
   <http://www.maxb.net/scripts/jgcharts/include/demo/>`_.
   :func:`graph_template` then inserts the ionogram image into the
   DOM node ``graph_node``.

Searching and Sorting Functions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. function:: submitControlForm()

   Submit the control form, generating a new set of results. This function
   is called by several sorting-related functions.

.. function:: setSorting(sortkey)

   Set the value of the :ref:`sortfield <sortfield>` to ``sortkey``. If the
   sortfield is already set to ``sortkey``, reverse the sort order.
   For example, if ``sortkey == "experiment"`` and the sortfield contains
   ``"project"`` then :func:`setSorting` will set the the sortfield to
   ``"-project"``.

   After setting the sortfield, :func:`setSorting` calls
   :func:`submitControlForm`.

.. function:: getSortKey(sortable_th)

   Extract the :ref:`sortkey <sortkey>` from the jQuery-wrapped ``th`` node
   ``sortable_th``.

.. function:: selectedSortField()

   Return the :ref:`sortkey <sortkey>` corresponding to the current field
   for sorting,
   extracted from the :ref:`sortfield <sortfield>`. For example, if
   the sortfield
   contains either ``"project"`` or ``"-project"``, :func:`selectedSortField`
   returns ``"project"``.

.. function:: sorterIsSelected(sortkey)

   Return ``true`` if ``sortkey`` is the current field selected for sorting.

.. function:: sortClickCbFactory(rev,sortkey,sfelement)

   Return a closure which sets the value of ``sfelement`` to ``'-' + sortkey``
   or ``sortkey`` depending on whether ``rev`` is ``true`` or ``false``,
   respectively.

   Normally, ``sfelement`` should be the :ref:`sortfield <sortfield>`.

.. function:: addSortIcon()

   Creates two `icons <http://jqueryui.com/themeroller/>`_, an up arrow
   (``ui-icon-arrowthick-1-n``) and a down arrow (``ui-icon-arrowthick-1-s``).
   :func:`addSortIcon` then appends the icons to the node with class 
   "sortheading" under node ``this``.

.. function:: docHasSortable()
   
   Returns ``true`` if the page contains a :ref:`sortfield <sortfield>`.

Tooltip Functions
^^^^^^^^^^^^^^^^^

.. data:: HOVER_TIMEOUTS

   Dictionary mapping timeout ID's returned by `setTimeout
   <http://www.w3schools.com/js/js_timing.asp>` to URL's which identify the
   tooltip to be displayed once the timeout has expired. Keeping around
   these mappings makes it easy to cancel a timeout in the event that the
   user mouses off of a tooltip before the timeout has passed.

.. data:: TOOLTIP_KEYS

   A cache of previously loaded tooltip data.

.. function:: tooltipCbFactory(ele,url)

   Return a closure takes a JSON object returned by jQuery `getJSON()
   <http://api.jquery.com/jQuery.getJSON/>`_ and displays the tooltip
   information in that object using a dialog box. The dialog box appears
   slightly below DOM node ``ele``.

.. function:: tooltipClose()

   Remove the "tooltip_highlighted" class from ``this``, cancel any
   timeouts associated with the tooltip under ``this``, and hide
   the tooltip dialog box if it is showing.

.. function:: extractUrl(ele)

   Return the tooltip URL contained in the text of ``ele``. This URL can
   be used to:
   
   * Uniquely identify a tooltip
   * Retrieve data from the web server (via jQuery `getJSON 
     <http://api.jquery.com/jQuery.getJSON/>`_) to display the tooltip.

   :func:`extractUrl` extracts the tooltip URL from the following structure::

     <span id="the_ele_passed_in>
         ...
	 <span class=".tooltip">/the/url/to/extract</span>
     </span>	   
    
.. function:: _tt(url,cb)

   Checks :data:`TOOLTIP_KEYS` to see if the tooltip for ``url`` has already
   been retrieved. If so, call ``cb`` on the the tooltip data. Otherwise,
   use jQuery `getJSON() <http://api.jquery.com/jQuery.getJSON/>`_ to
   retrieve the tooltip data, using ``cb`` as the callback argument to
   `getJSON()`.

.. function:: retrieveTooltip()

   First, adds the class "tooltip_highlighted" to ``this``. Next, calls 
   `setTimeout <http://www.w3schools.com/js/js_timing.asp>`_, which begins
   the process of retrieving and displaying the tooltip for ``this``.

.. function:: displaySummary(d,keys)

   Given the data for all tooltips on a page (``d``), and the URL's for each
   tooltip in ``keys``, pop up a dialog box that displays the title and
   text of every tooltip on the page.

.. function:: retrieveAllTooltips(tips)

   For each element in ``tips`` retrieve the associated tooltip data and
   store the data in a dictionary keyed by the tooltip's URL. When all
   tooltips have been entered into the dictionary, call :func:`displaySummary`
   with the dictionary and list of URL's as arguments.

.. gatherTooltips()
   
   Find all tooltips on the page with ``$(".tooltip).parent()`` and
   call :func:`retrieveAllTooltips` on the result.
   

Sorting
-------

The sortable columns in the "Experiments" and "Reports" pages rely on elements
from all levels of the UI stack.

Making A Column Sortable
^^^^^^^^^^^^^^^^^^^^^^^^

The UI's sorting mechanism assumes that you are attempting to sort data laid
out in an HTML table. There should be a ``th`` elements at the top of each
column. The top row (``tr``) of the column must have the class "sortables".
Each ``th`` at the top of a sortable column must contain at least the following
two nodes:

* A node with class "sortheading"
* A node with class "sortkey"

The structure of the table should look something like this::

  <table><thead>
    <tr class="sortables">
      ...
      <th>
        <div class="sortheading">Name of Column</div>
	<div class="sortkey">corresponding_model_field</div>
	<!-- additional nodes allowed here -->
      </th>
     </tr>
   </thead>...</table>

.. _sortkey:

The "sortheading" node should contain the name of the column - the actual text
that will appear on the rendered page. The "sortkey" node will be hidden. It
should contain the name of the database field corresponding that will actually
be used for sorting. For example, when sorting ``model.Experiment`` objects::

   <div class="sortheading">PGM</div>
   <div class="sortkey">pgmname</div>

could be used to sort by the ``pgmName`` setting. Note that the "sortkey" text
is case-insensitive.

The :func:`prep_sorting_text` and :func:`prep_sorting_buttons` jQuery callbacks
will take care of adding the necessary buttons and event handlers to make the
column sortable.

Enabling Sorting On A Page
^^^^^^^^^^^^^^^^^^^^^^^^^^

The column to sort on, and the sort order (ascending vs. descending) is passed
to the web server with a hidden form field. The page containing the sortable
table should include a ``form`` with ID "control_form". That is, it should
contain something like::

   <form id="control_form" ...>
      ...
   </form>

.. _sortfield:

The view that renders the page's template (for example
:func:`rundb.views.experiment`) should create an instance of
``forms.SortForm``. The template should then render the ``SortForm``'s
``sortfield`` within the control form::

   <form id="control_form" ...>
     ...
     <!-- other forms and fields -->
     ...
     {{sortform.sortfield}}
   </form>

This example assumes that the ``SortForm`` instance is included in the
template context as "sortform". The field inserted into the form is styled
so as to be invisible -- it uses input type "hidden".

In order to actually sort information, the view will need to process the data
found in the sortfield. The :mod:`rundb.views` module provides an easy way to
sort (and search) data for a particular model. Use the
:func:`rundb.views.search_and_sort`
function, with a ``SortForm`` instance as one of the arguments, to return
a sorted queryset.

Sorting Internals
^^^^^^^^^^^^^^^^^

The :func:`prep_sorting_text` and :func:`prep_sorting_buttons` significantly
modify the page's DOM tree in order to add UI elements necessary for sorting.

:func:`prep_sorting_text` binds a click event to sortable column titles. When
the event is triggered, it calls :func:`setSorting` with the column's *sortkey*
as the argument. The *sortkey* is the content of the node with class "sortkey"
in the ``th`` element holding the column name::

   ...
   <th>
     <div class="sortheading">The Column Name</div>
     <div class="sortkey">the_sortkey</div>
   </th>
   ...

:func:`setSorting` sets the value of the the hidden input with class
"sortfield" living in the control form. It then calls
:func:`submitControlForm`, which submits the form.

:func:`prep_sorting_buttons` calls :func:`addSortIcon` on all nodes matching
``$(".sortables > th")``.

Searching
---------

As with sorting, searching assumes the presence of a form with ID
"control_form". A search-enabled view (such as :func:`rundb.views.experiment`)
should create an instance of :class:`rundb.forms.SearchForm`.

The template should render the ``SearchForm``'s ``searchterms`` field::

   <form id="control_form" ...>
     <table>
       ...
         <tr>
	 ...
	   <td>{{searchform.searchterms}}</td>
	 ...
	 </tr>
     </table> 
   </form>

This assumes that the ``SearchForm`` instance is included in the template
context as ``searchform``. The ``searchterms`` field has class "searchbox",
which appears in ``iondb/media/stylesheet.css``.

In the view, the ``SearchForm`` instance should be passed to
:func:`rundb.views.search_and_sort` for the purposes of searching the
queryset.

CSS
---

The UI's styling is probably its least organized component. There is no real
naming convention or grouping to all the styles in
``iondb/media/stylesheet.css``. That being said, it should be a fairly
straightforward job to refactor all the styling (see the :ref:`future-work`
section).

In addition, styles used in the Django templates mix those defined in
``stylesheet.css`` and those defined by the UI's jQuery theme. Anything
that matches the wildcard pattern ``ui-*`` is generally a jQuery style.

Quick Tips and Gotchas
----------------------

* If you add a tooltip to a template and get an "invalid tag" Django exception,
  you need to add the tag ``{% load embeddedhelp %}`` somewhere in that
  template.
* Much of the CSS for buttons is applied by JavaScript. If you're trying to
  change the look of an interactive component and modifying
  ``iondb/media/stylesheet.css``
  isn't having an effect, you might want to check ``iondb/media/scripts.js``.
  While handling some styling in JavaScript made it easier to play with look
  and feel, this should probably be factored out into a stylesheet.

.. _future-work:

Future Work
-----------

* Refactor ``iondb/media/scripts.js`` into several files, with the files
  organized by functionality. For example, we might want files such as
  ``iondb/media/sorting.js`` and ``iondb/media/searching.js``.
* Add namespacing to ``iondb/media/scripts.js``.
* Organize ``iondb/media/stylesheet.css`` and perhaps rename styles in order
  to achieve a consistent naming convention. Break the file up into subfiles.
* `Roll a custom jQuery theme <http://jqueryui.com/themeroller/>`_.
* Replace the two-button sorting controls with a single, toggling button.